#!/usr/bin/env python3
import yaml
import paramiko
import colorama
import os
import sys
import threading
import logging
from typing import List, Dict
from concurrent.futures import ThreadPoolExecutor, as_completed

# Initialize colorama for cross-platform terminal colors
colorama.init(autoreset=True)

# Configure logging to neutron.log
logging.basicConfig(
    filename='neutron.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)


class LinuxSSHTool:
    """
    Lightweight SSH automation tool for executing commands on multiple Linux servers.
    Supports parallel/serial execution, interactive mode, and task files.
    """
    def __init__(self):
        """
        Initialize the tool by loading configuration and server list.
        Also set up SSH session cache and output synchronization lock.
        """
        self.config = self.load_config()
        self.servers = self.load_servers()
        self.ssh_sessions = {}  # Cache for SSH sessions (host:port -> SSHClient)
        self.print_lock = threading.Lock()  # Lock for synchronized console output

    def load_config(self) -> Dict:
        """
        Load SSH configuration from config.cfg.
        Requirements:
            - config.cfg must not be empty or invalid.
            - SSH user must be defined.
            - Either key_path or password must be provided (not both).
            - max_workers (default: 10) and timeout (default: 30) are set for parallel execution.
        Gereksinimler:
            - config.cfg boÅŸ veya geÃ§ersiz olmamalÄ±.
            - SSH kullanÄ±cÄ±sÄ± tanÄ±mlÄ± olmalÄ±.
            - key_path veya password saÄŸlanmalÄ± (ikisi birden deÄŸil).
            - Paralel Ã§alÄ±ÅŸtÄ±rma iÃ§in max_workers (varsayÄ±lan: 10) ve timeout (varsayÄ±lan: 30) ayarlanÄ±yor.
        """
        try:
            with open('config.cfg') as f:
                config = yaml.safe_load(f)
                if not config:
                    raise ValueError("config.cfg is empty or invalid.")

            ssh_config = config.get('ssh')
            if not ssh_config or not ssh_config.get('user'):
                raise ValueError("Invalid config.cfg: SSH user is not defined.")

            # Prevent using both key_path and password
            if ssh_config.get('key_path') and ssh_config.get('password'):
                raise ValueError("Please provide either a key_path or password, not both.")

            # Ensure authentication method is provided
            if not ssh_config.get('key_path') and not ssh_config.get('password'):
                raise ValueError("No authentication method provided: Define either key_path or password.")

            # Set defaults
            ssh_config['max_workers'] = ssh_config.get('max_workers', 10)
            ssh_config['timeout'] = ssh_config.get('timeout', 30)
            ssh_config['port'] = ssh_config.get('port', 22)
            return ssh_config

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}[ERROR] Failed to load config: {e}")
                logging.error(f"Failed to load config: {e}")
            sys.exit(1)

    def load_servers(self) -> List[Dict]:
        """
        Load the list of servers from source.yaml.
        - source.yaml must be valid and non-empty.
        - Each server must have a non-empty host and valid port.
        - source.yaml geÃ§erli ve boÅŸ olmamalÄ±.
        - Her sunucunun geÃ§erli bir host ve port deÄŸeri olmalÄ±.
        """
        try:
            with open('source.yaml') as f:
                data = yaml.safe_load(f)
                if not data:
                    raise ValueError("source.yaml is empty or invalid.")
                servers = data.get('servers', [])

            normalized = []
            for s in servers:
                if isinstance(s, str):
                    if not s.strip():
                        raise ValueError("Empty host provided in source.yaml")
                    normalized.append({'host': s.strip(), 'port': self.config.get('port', 22)})
                elif isinstance(s, dict):
                    host = s.get('host')
                    if not host or not host.strip():
                        raise ValueError("Invalid or empty host in source.yaml")
                    port = s.get('port', self.config.get('port', 22))
                    if not isinstance(port, int) or port <= 0 or port > 65535:
                        raise ValueError(f"Invalid port for host {host}: {port}")
                    normalized.append({'host': host.strip(), 'port': port})
                else:
                    raise ValueError("Server items must be either string or dict.")
            return normalized

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}[ERROR] Failed to load server list: {e}")
                logging.error(f"Failed to load server list: {e}")
            sys.exit(1)

    def get_ssh_session(self, host: str, port: int) -> paramiko.SSHClient:
        """
        Get or create an SSH session for the given host and port.
        Reuses existing connections to improve performance.
        Verilen host ve port iÃ§in SSH oturumu alÄ±r veya oluÅŸturur.
        PerformansÄ± artÄ±rmak iÃ§in mevcut baÄŸlantÄ±larÄ± yeniden kullanÄ±r.
        """
        key = f"{host}:{port}"
        if key not in self.ssh_sessions:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            connect_params = {
                'hostname': host,
                'port': port,
                'username': self.config['user'],
            }
            if self.config.get('key_path'):
                connect_params['key_filename'] = os.path.expanduser(self.config['key_path'])
            elif self.config.get('password'):
                connect_params['password'] = self.config['password']
            ssh.connect(**connect_params)
            self.ssh_sessions[key] = ssh
        return self.ssh_sessions[key]

    def run_command(self, host: str, port: int, command: str):
        """
        Run a command on a remote host via SSH.
        - Checks for dangerous commands and requires confirmation.
        - Uses pseudo-terminal (get_pty=True) for terminal-dependent commands (e.g., clear).
        - Sets TERM=xterm to avoid issues with commands like 'clear'.
        - Uzak sunucuda komut Ã§alÄ±ÅŸtÄ±rÄ±r.
        - Tehlikeli komutlarÄ± kontrol eder ve onay gerektirir.
        - Terminal baÄŸÄ±mlÄ± komutlar iÃ§in pseudo-terminal kullanÄ±r (get_pty=True).
        - clear gibi komutlar iÃ§in TERM=xterm ayarlar.
        """
        # Check for dangerous commands
        dangerous_commands = ['rm -rf /', 'reboot', 'shutdown']
        if any(dc in command.lower() for dc in dangerous_commands):
            with self.print_lock:
                print(f"{colorama.Fore.RED}   âš ï¸ Dangerous command detected: {command}")
                if input("Continue? (y/n): ").lower() != 'y':
                    return

        try:
            with self.print_lock:
                print(f"\n{colorama.Fore.CYAN}ðŸ”¹ Connecting to {host}:{port}")
                print(f"   {colorama.Fore.YELLOW}$ {command}")
                logging.info(f"Connecting to {host}:{port} to run: {command}")

            ssh = self.get_ssh_session(host, port)
            # Set TERM environment variable and use pseudo-terminal
            env_command = f"export TERM=xterm; {command}"
            stdin, stdout, stderr = ssh.exec_command(
                env_command,
                timeout=self.config['timeout'],
                get_pty=True
            )
            output = stdout.read().decode().strip()
            error = stderr.read().decode().strip()

            with self.print_lock:
                if output:
                    if len(output) > 1000:
                        print(f"{colorama.Fore.GREEN}   âœ… Output ({host}, truncated):\n{output[:1000]}...")
                        output_file = f"output_{host}_{port}.txt"
                        with open(output_file, 'w') as f:
                            f.write(output)
                        print(f"{colorama.Fore.YELLOW}   ðŸ“ Full output saved to {output_file}")
                        logging.info(f"Output from {host}:{port} saved to {output_file}")
                    else:
                        print(f"{colorama.Fore.GREEN}   âœ… Output ({host}):\n{output}")
                        logging.info(f"Output from {host}:{port}: {output}")
                if error:
                    print(f"{colorama.Fore.RED}   â— Error ({host}):\n{error}")
                    logging.error(f"Error from {host}:{port}: {error}")
                if not output and not error:
                    print(f"{colorama.Fore.YELLOW}   âš ï¸ No output returned from {host}.")
                    logging.info(f"No output from {host}:{port}")

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}   âŒ Connection error on {host}: {str(e)}")
                logging.error(f"Connection error on {host}:{port}: {str(e)}")
            raise

    def execute_task(self, task_file: str):
        """
        Execute commands from a YAML task file on all servers.
        Supports parallel or serial execution based on 'parallel' key in task file.
        Task file example:
            parallel: true
            commands:
              - "uptime"
              - "df -h"
        YAML gÃ¶rev dosyasÄ±ndaki komutlarÄ± tÃ¼m sunucularda Ã§alÄ±ÅŸtÄ±rÄ±r.
        'parallel' anahtarÄ±na baÄŸlÄ± olarak paralel veya sÄ±ralÄ± Ã§alÄ±ÅŸtÄ±rma destekler.
        """
        try:
            with open(task_file) as f:
                task_data = yaml.safe_load(f)
                if not task_data:
                    raise ValueError("Task file is empty or invalid.")
                commands = task_data.get('commands', [])
                if not commands:
                    raise ValueError("No commands defined in the task file.")
                parallel = task_data.get('parallel', True)

            with self.print_lock:
                print(f"{colorama.Fore.BLUE}[INFO] Executing task file: {task_file}")
                print(f"{colorama.Fore.BLUE}[INFO] Parallel execution: {'Enabled' if parallel else 'Disabled'}")
                logging.info(f"Executing task file: {task_file}, Parallel: {parallel}")

            errors = []
            if parallel:
                max_workers = self.config.get('max_workers', 10)
                with ThreadPoolExecutor(max_workers=max_workers) as executor:
                    futures = [
                        executor.submit(self.run_command, server['host'], server['port'], cmd)
                        for server in self.servers
                        for cmd in commands
                    ]
                    for future in as_completed(futures):
                        try:
                            future.result()
                        except Exception as e:
                            errors.append(str(e))
            else:
                for server in self.servers:
                    for cmd in commands:
                        try:
                            self.run_command(server['host'], server['port'], cmd)
                        except Exception as e:
                            errors.append(str(e))

            if errors:
                with self.print_lock:
                    print(f"{colorama.Fore.RED}[SUMMARY] Errors occurred during execution:")
                    for error in errors:
                        print(f"{colorama.Fore.RED}  - {error}")
                    logging.error(f"Task execution errors: {errors}")

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}[ERROR] Task execution failed: {e}")
                logging.error(f"Task execution failed: {e}")

    def interactive_mode(self):
        """
        Interactive mode for manual SSH command input.
        Supports switching between parallel and serial execution with 'parallel:on/off'.
        KullanÄ±cÄ± terminal Ã¼zerinden komut girebilir.
        'parallel:on/off' ile paralel/sÄ±ralÄ± Ã§alÄ±ÅŸtÄ±rma arasÄ±nda geÃ§iÅŸ yapabilir.
        """
        print(f"{colorama.Fore.MAGENTA}#######################################################################")
        print(f"{colorama.Fore.MAGENTA}###                            NEUTRON                              ###")
        print(f"{colorama.Fore.MAGENTA}### ðŸ§ Lightweight automation tool for Linux (Type 'exit' to quit) ###")
        print(f"{colorama.Fore.MAGENTA}###                     www.farukguler.com                         ###")
        print(f"{colorama.Fore.MAGENTA}#######################################################################")
        print(f"{colorama.Fore.BLUE}[INFO] Maximum parallel connections: {self.config.get('max_workers', 10)}")
        print(f"{colorama.Fore.BLUE}[INFO] Command timeout: {self.config.get('timeout', 30)} seconds")
        print(f"{colorama.Fore.BLUE}[INFO] Available commands:")
        print(f"{colorama.Fore.BLUE}       - Type a shell command to execute on all servers")
        print(f"{colorama.Fore.BLUE}       - Type 'parallel:on' to enable parallel execution")
        print(f"{colorama.Fore.BLUE}       - Type 'parallel:off' to disable parallel execution")
        print(f"{colorama.Fore.BLUE}       - Type 'exit' or 'quit' to exit")

        parallel_mode = False
        while True:
            try:
                cmd = input(f"{colorama.Fore.CYAN}\nssh{'(parallel)' if parallel_mode else ''}> ").strip()
                if cmd.lower() in ['exit', 'quit']:
                    break
                elif cmd.lower() == 'parallel:on':
                    parallel_mode = True
                    print(f"{colorama.Fore.GREEN}[INFO] Parallel execution enabled")
                    logging.info("Parallel execution enabled")
                    continue
                elif cmd.lower() == 'parallel:off':
                    parallel_mode = False
                    print(f"{colorama.Fore.GREEN}[INFO] Parallel execution disabled")
                    logging.info("Parallel execution disabled")
                    continue

                errors = []
                if parallel_mode:
                    max_workers = self.config.get('max_workers', 10)
                    with ThreadPoolExecutor(max_workers=max_workers) as executor:
                        futures = [
                            executor.submit(self.run_command, server['host'], server['port'], cmd)
                            for server in self.servers
                        ]
                        for future in as_completed(futures):
                            try:
                                future.result()
                            except Exception as e:
                                errors.append(str(e))
                else:
                    for server in self.servers:
                        try:
                            self.run_command(server['host'], server['port'], cmd)
                        except Exception as e:
                            errors.append(str(e))

                if errors:
                    with self.print_lock:
                        print(f"{colorama.Fore.RED}[SUMMARY] Errors occurred during execution:")
                        for error in errors:
                            print(f"{colorama.Fore.RED}  - {error}")
                        logging.error(f"Interactive mode errors: {errors}")

            except KeyboardInterrupt:
                print(f"{colorama.Fore.RED}\nExiting...")
                logging.info("Exiting interactive mode")
                break

    def __del__(self):
        """
        Close all SSH sessions when the object is destroyed.
        Nesne yok edildiÄŸinde tÃ¼m SSH oturumlarÄ±nÄ± kapatÄ±r.
        """
        for ssh in self.ssh_sessions.values():
            ssh.close()


if __name__ == "__main__":
    tool = LinuxSSHTool()
    if len(sys.argv) > 1:
        tool.execute_task(sys.argv[1])
    else:
        tool.interactive_mode()
