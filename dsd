#!/bin/bash

# Renk tanımlamaları
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m' # Renk yok

# Banner
echo -e "${CYAN}###########################################################${NC}
${GREEN}# Neutron v10 - Revize Edilmiş${NC}
# Linux/Unix için hafif ve güçlü otomasyon aracı
# Sayfa: www.farukguler.com github.com/faruk-guler
# Yazar: faruk-guler

${YELLOW}Neutron Kullanımı:${NC}
${GREEN}cd <dizin>${NC}          : Tüm uzak hostlarda dizin değiştir
${GREEN}put <yerel_yol> [uzak_yol]${NC} : Tüm uzak hostlara dosya/dizin yükle (paralel)
${GREEN}get <uzak_yol> [yerel_dizin]${NC} : Tüm uzak hostlardan dosya/dizin indir (paralel)
${GREEN}<herhangi_kabuk_komutu>${NC} : Tüm uzak hostlarda kabuk komutu çalıştır
${RED}exit${NC}                 : Neutron'dan çık
${CYAN}###########################################################${NC}"

# Geçmiş dosyası
HISTORY_FILE="$HOME/.neutron_history"
touch "$HISTORY_FILE"

# Readline ayarları (etkileşimli kabuk için)
if [[ $- == *i* ]]; then
    bind '"\e[A": history-search-backward' # Yukarı ok: geçmişte geri ara
    bind '"\e[B": history-search-forward'  # Aşağı ok: geçmişte ileri ara
    bind 'set show-all-if-ambiguous on'
    bind 'set completion-ignore-case on'
    bind 'TAB: menu-complete'
fi

# Yapılandırma dosyalarını yükle
source config.ntr || { echo -e "${RED}Hata: config.ntr bulunamadı! Lütfen oluşturun ve SSH kimlik bilgilerinizi girin.${NC}"; exit 1; }
source sources.ntr || { echo -e "${RED}Hata: sources.ntr bulunamadı! Lütfen oluşturun ve sunucu listenizi girin.${NC}"; exit 1; }

# Gerekli değişkenlerin kontrolü
[ -z "${HOSTS+x}" ] && { echo -e "${RED}Hata: HOSTS sources.ntr dosyasında tanımlanmamış.${NC}" >&2; exit 1; }
[ -z "${USER+x}" ] && { echo -e "${RED}Hata: USER config.ntr dosyasında tanımlanmamış.${NC}" >&2; exit 1; }
[ -z "${PRIVATE_KEY_FILE+x}" ] && { echo -e "${RED}Hata: PRIVATE_KEY_FILE config.ntr dosyasında tanımlanmamış.${NC}" >&2; exit 1; }

# Özel anahtar doğrulama fonksiyonu
validate_private_key() {
    local key_file="$1"

    if [ ! -f "$key_file" ]; then
        echo -e "${RED}Hata: Özel anahtar dosyası '$key_file' mevcut değil.${NC}" >&2
        return 1
    fi

    if [ ! -r "$key_file" ]; then
        echo -e "${RED}Hata: Özel anahtar dosyası '$key_file' okunabilir değil.${NC}" >&2
        return 1
    fi

    # Dosya izinlerini kontrol et (600 veya 400 olmalı)
    local perms=$(stat -c "%a" "$key_file" 2>/dev/null)
    if [[ "$perms" != "600" && "$perms" != "400" ]]; then
        echo -e "${YELLOW}Uyarı: Özel anahtar dosyası izinleri 600 veya 400 olmalı (mevcut: $perms).${NC}" >&2
    fi

    # Anahtar formatını doğrula
    if ! ssh-keygen -l -f "$key_file" >/dev/null 2>&1; then
        echo -e "${RED}Hata: '$key_file' dosyasındaki özel anahtar formatı geçersiz.${NC}" >&2
        return 1
    fi

    return 0
}

# Başlangıçta özel anahtarı doğrula
if ! validate_private_key "$PRIVATE_KEY_FILE"; then
    exit 1
fi

# SSH komutu oluşturma fonksiyonu
build_ssh_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3" # Ek SSH seçenekleri

    local -a ssh_args=(
        $options
        -o ConnectTimeout=5 # Bağlantı zaman aşımı
        -o StrictHostKeyChecking=no # Geliştirme/otomasyon için. Üretimde kaldırılması veya 'yes' yapılması önerilir!
        -p "$port"
        -i "$PRIVATE_KEY_FILE"
        "$USER@$host_or_ip"
    )
    echo "${ssh_args[@]}"
}

# SCP komutu oluşturma fonksiyonu
build_scp_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3" # Ek SCP seçenekleri

    local -a scp_args=(
        $options
        -P "$port"
        -o StrictHostKeyChecking=no # Geliştirme/otomasyon için. Üretimde kaldırılması veya 'yes' yapılması önerilir!
        -i "$PRIVATE_KEY_FILE"
    )
    echo "${scp_args[@]}"
}

# Oturum verilerini başlat
declare -A current_dir host_ports host_names outputs

# Her host için mevcut dizini başlat ve hostname'leri bir kez çek
for host_port_entry in "${HOSTS[@]}"; do
    IFS=: read host_or_ip port <<< "$host_port_entry"
    current_dir["$host_or_ip"]="/tmp" # Her host için varsayılan dizin
    host_ports["$host_or_ip"]="${port:-22}" # Portu sakla, yoksa varsayılan 22 kullan

    # Hostname'i başlangıçta bir kez çek
    ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "${host_ports[$host_or_ip]}" "-n"))
    remote_hostname=$(ssh "${ssh_cmd_arr[@]}" "hostname" 2>/dev/null)

    if [ -z "$remote_hostname" ]; then
        echo -e "${YELLOW}Uyarı: $host_or_ip için hostname alınamadı. Görüntüleme için orijinal hedef kullanılıyor.${NC}" >&2
        host_names["$host_or_ip"]="$host_or_ip"
    else
        host_names["$host_or_ip"]="$remote_hostname"
    fi
done

# Çıkışta geçici dosyaları temizle
trap 'rm -f "${outputs[@]}"' EXIT

# Komut geçmişini yükle
history -r "$HISTORY_FILE"

# Ana döngü
while read -e -p "$(echo -e "${GREEN}neutron # ${NC}")" -r cmd; do
    history -s "$cmd"
    history -w "$HISTORY_FILE"

    [ -z "$cmd" ] && continue
    [ "$cmd" = "exit" ] && break

    # Her komut döngüsü için işleri sıfırla
    unset -v jobs
    declare -A jobs

    # --- "cd" Komutunu İşle ---
    if [[ "$cmd" =~ ^cd\s ]]; then # "cd " ile başlayan komutları yakala
        dir="${cmd#cd }"
        dir="${dir%\"}" # Baştaki/sondaki tırnakları temizle
        dir="${dir#\"}"

        # Dizin boş olamaz
        if [ -z "$dir" ]; then
            echo -e "${RED}Hata: cd komutu için hedef dizin belirtmelisiniz.${NC}"
            continue
        fi

        for host_or_ip in "${!current_dir[@]}"; do
            port="${host_ports[$host_or_ip]}"
            ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" ""))

            # cd komutunu uzak hostta çalıştır ve başarısını kontrol et
            if ssh "${ssh_cmd_arr[@]}" "test -d \"$dir\" && cd \"$dir\" >/dev/null 2>&1"; then
                current_dir["$host_or_ip"]="$dir"
                echo -e "${GREEN}Dizin ${host_names[$host_or_ip]} üzerinde '$dir' olarak değiştirildi.${NC}"
            else
                echo -e "${YELLOW}Uyarı: ${host_names[$host_or_ip]} üzerinde '$dir' dizini mevcut değil veya dizin değiştirilemedi.${NC}"
            fi
        done
        continue
    fi

    # --- "put" Komutunu İşle (Dosya veya Dizin Yükleme) - Paralel SCP ---
    if [[ "$cmd" =~ ^put\s ]]; then
        # 'put' sonrası argümanları ayrıştır
        # Boşluk içeren yollar için tırnakları korumaya çalış
        IFS=$'\n' read -d '' -ra tokens < <(printf '%s\n' "${cmd#put }" | xargs -n 1)

        if [ ${#tokens[@]} -lt 1 ]; then
            echo -e "${RED}Hata: 'put' komutu için yerel yol belirtmelisiniz. Kullanım: put <yerel_yol> [uzak_yol]${NC}"
            continue
        fi

        local_path="${tokens[0]}"
        remote_path="${tokens[1]:-/tmp/$(basename "$local_path")}" # Varsayılan olarak /tmp'ye yüklensin

        if [ ! -e "$local_path" ]; then
            echo -e "${RED}Hata: Yerel yol '$local_path' mevcut değil.${NC}"
            continue
        fi

        for host_or_ip in "${!current_dir[@]}"; do
            port="${host_ports[$host_or_ip]}"
            echo -e "${GREEN}Yükleniyor: '$local_path' -> ${host_names[$host_or_ip]}:'$remote_path'${NC}"

            scp_cmd_arr=($(build_scp_cmd "$host_or_ip" "$port" ""))

            if [ -d "$local_path" ]; then
                scp "${scp_cmd_arr[@]}" -r "$local_path" "$USER@$host_or_ip:\"$remote_path\"" & # Dizin için -r
            else
                scp "${scp_cmd_arr[@]}" "$local_path" "$USER@$host_or_ip:\"$remote_path\"" &
            fi
            jobs["$host_or_ip"]="$!"
        done

        # Tüm transferlerin tamamlanmasını bekle
        for host_or_ip in "${!jobs[@]}"; do
            wait "${jobs[$host_or_ip]}"
            if [ $? -eq 0 ]; then
                echo -e "${GREEN}Başarılı: '$local_path' ${host_names[$host_or_ip]} üzerine yüklendi.${NC}"
            else
                echo -e "${RED}Başarısız: '$local_path' ${host_names[$host_or_ip]} üzerine yüklenemedi.${NC}"
            fi
        done
        continue
    fi

    # --- "get" Komutunu İşle (Dosya veya Dizin İndirme) - Paralel SCP ---
    if [[ "$cmd" =~ ^get\s ]]; then
        # 'get' sonrası argümanları ayrıştır
        IFS=$'\n' read -d '' -ra tokens < <(printf '%s\n' "${cmd#get }" | xargs -n 1)

        if [ ${#tokens[@]} -lt 1 ]; then
            echo -e "${RED}Hata: 'get' komutu için uzak yol belirtmelisiniz. Kullanım: get <uzak_yol> [yerel_dizin]${NC}"
            continue
        fi

        remote_path="${tokens[0]}"
        local_dir="${tokens[1]:-./downloads}"

        mkdir -p "$local_dir" 2>/dev/null || {
            echo -e "${RED}Hata: '$local_dir' dizini oluşturulamadı veya erişilemiyor.${NC}"
            continue
        }

        for host_or_ip in "${!current_dir[@]}"; do
            port="${host_ports[$host_or_ip]}"
            echo -e "${GREEN}İndiriliyor: ${host_names[$host_or_ip]}:'$remote_path' -> '$local_dir/'${NC}"

            scp_cmd_arr=($(build_scp_cmd "$host_or_ip" "$port" ""))
            ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" ""))

            target_host_dir="$local_dir/${host_names[$host_or_ip]}"
            mkdir -p "$target_host_dir" 2>/dev/null || {
                echo -e "${RED}Hata: ${host_names[$host_or_ip]} için '$target_host_dir' dizini oluşturulamadı.${NC}"
                continue
            }

            # Uzak yolun dosya mı dizin mi olduğunu kontrol et
            is_dir=$(ssh "${ssh_cmd_arr[@]}" "[ -d \"$remote_path\" ] && echo 'yes' || echo 'no'" 2>/dev/null)

            if [ "$is_dir" = "yes" ]; then
                scp "${scp_cmd_arr[@]}" -r "$USER@$host_or_ip:\"$remote_path\"" "$target_host_dir" & # Dizin için -r
            else
                scp "${scp_cmd_arr[@]}" "$USER@$host_or_ip:\"$remote_path\"" "$target_host_dir" &
            fi
            jobs["$host_or_ip"]="$!"
        done

        # Tüm indirmelerin tamamlanmasını bekle
        for host_or_ip in "${!jobs[@]}"; do
            wait "${jobs[$host_or_ip]}"
            if [ $? -eq 0 ]; then
                echo -e "${GREEN}Başarılı: '$remote_path' ${host_names[$host_or_ip]}'dan indirildi.${NC}"
            else
                echo -e "${RED}Başarısız: '$remote_path' ${host_names[$host_or_ip]}'dan indirilemedi.${NC}"
            fi
        done
        continue
    fi

    # --- Diğer Tüm Komutları İşle (Paralel Kabuk Komutları) ---
    first_output_block=true
    for host_or_ip in "${!current_dir[@]}"; do
        port="${host_ports[$host_or_ip]}"
        temp_file=$(mktemp)
        outputs["$host_or_ip"]="$temp_file"

        ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" "-n"))
        # Uzak komut, mevcut dizini koruyarak çalıştırılır
        remote_cmd="cd \"${current_dir[$host_or_ip]}\" && $cmd"

        ssh "${ssh_cmd_arr[@]}" "$remote_cmd" > "$temp_file" 2>&1 &
        jobs["$host_or_ip"]="$!"
    done

    # Tüm hostlardan gelen sonuçları bekle ve yazdır
    for host_or_ip in "${!jobs[@]}"; do
        wait_status=0
        wait "${jobs[$host_or_ip]}" || wait_status=$? # Komutun çıkış durumunu yakala

        remote_display_name="${host_names[$host_or_ip]}"
        mapfile -t lines < "${outputs[$host_or_ip]}"

        # Yalnızca çıktı varsa VEYA komut sıfır olmayan bir durumla çıkış yaptıysa yazdır
        if [ ${#lines[@]} -gt 0 ] || [ $wait_status -ne 0 ]; then
            if ! $first_output_block; then
                echo "" # Her blok arasına boşluk koy
            fi
            echo -e "${BLUE}--- host: ${remote_display_name} (Çıkış Kodu: $wait_status) ---${NC}"

            if [ ${#lines[@]} -gt 0 ]; then
                printf "%s\n" "${lines[@]}"
            fi

            echo -e "${RED}----------------------------------------------------${NC}"
            first_output_block=false
        fi
        rm "${outputs[$host_or_ip]}"
    done
done
