seek#!/usr/bin/env python3
import paramiko
import yaml
import threading
from concurrent.futures import ThreadPoolExecutor

class SimpleSSHTool:
    def __init__(self):
        self.config = self.load_config()
        self.servers = self.load_servers()
        self.ssh_sessions = {}
        self.lock = threading.Lock()

    def load_config(self):
        with open('config.yaml') as f:
            config = yaml.safe_load(f)
        
        if not config.get('user'):
            raise ValueError("SSH user must be defined")
        
        if not (config.get('key_path') or config.get('password')):
            raise ValueError("Provide either key_path or password")
        
        config.setdefault('port', 22)
        config.setdefault('timeout', 30)
        config.setdefault('max_workers', 10)
        
        return config

    def load_servers(self):
        with open('hosts.yaml') as f:
            hosts = yaml.safe_load(f)
        
        servers = []
        for host in hosts.get('servers', []):
            if isinstance(host, str):
                servers.append({'host': host, 'port': self.config['port']})
            elif isinstance(host, dict):
                servers.append({
                    'host': host['host'],
                    'port': host.get('port', self.config['port'])
                })
        return servers

    def get_connection(self, host, port):
        key = f"{host}:{port}"
        if key not in self.ssh_sessions:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            connect_args = {
                'hostname': host,
                'port': port,
                'username': self.config['user'],
                'timeout': self.config['timeout']
            }
            
            if self.config.get('key_path'):
                connect_args['key_filename'] = self.config['key_path']
            else:
                connect_args['password'] = self.config['password']
            
            ssh.connect(**connect_args)
            self.ssh_sessions[key] = ssh
        
        return self.ssh_sessions[key]

    def run_command(self, host, port, command):
        ssh = self.get_connection(host, port)
        
        stdin, stdout, stderr = ssh.exec_command(
            command,
            get_pty=True,
            timeout=self.config['timeout']
        )
        
        output = stdout.read().decode().strip()
        error = stderr.read().decode().strip()
        
        with self.lock:
            print(f"\n[{host}]")
            if output:
                print(f"Output:\n{output}")
            if error:
                print(f"Error:\n{error}")

    def execute(self, commands, parallel=True):
        if parallel:
            with ThreadPoolExecutor(max_workers=self.config['max_workers']) as executor:
                futures = []
                for server in self.servers:
                    for cmd in commands:
                        futures.append(
                            executor.submit(
                                self.run_command,
                                server['host'],
                                server['port'],
                                cmd
                            )
                        )
                
                for future in futures:
                    future.result()
        else:
            for server in self.servers:
                for cmd in commands:
                    self.run_command(server['host'], server['port'], cmd)

    def interactive(self):
        print("Simple SSH Tool (Ctrl+C to exit)")
        while True:
            try:
                cmd = input("> ").strip()
                if not cmd:
                    continue
                
                self.execute([cmd])
            
            except KeyboardInterrupt:
                print("\nExiting...")
                break

    def __del__(self):
        for ssh in self.ssh_sessions.values():
            ssh.close()

if __name__ == "__main__":
    tool = SimpleSSHTool()
    
    if len(sys.argv) > 1:
        with open(sys.argv[1]) as f:
            task = yaml.safe_load(f)
        tool.execute(task.get('commands', []), task.get('parallel', True))
    else:
        tool.interactive()
