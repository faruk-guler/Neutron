#!/bin/bash

# Color definitions
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly RED='\033[0;31m'
readonly NC='\033[0m' # No Color

# Configuration defaults (can be overridden in config.ntr)
readonly DEFAULT_CONNECT_TIMEOUT=10
readonly DEFAULT_QUICK_TIMEOUT=3
readonly DEFAULT_CONTROL_PERSIST="60s"
readonly DEFAULT_MAX_POOL_SIZE=10
readonly DEFAULT_SSH_OPTIONS="-o StrictHostKeyChecking=no"

# Global state management
declare -A g_current_dir g_host_ports g_host_names g_outputs g_jobs g_connection_pool
declare -g g_connection_pool_size=0
declare -g g_history_file="$HOME/.neutron_history"
declare -g g_ssh_control_path="$HOME/.ssh/neutron-%r@%h:%p"

# Configuration variables (loaded from config files)
declare -g NEUTRON_CONNECT_TIMEOUT NEUTRON_QUICK_TIMEOUT NEUTRON_CONTROL_PERSIST 
declare -g NEUTRON_MAX_POOL_SIZE NEUTRON_SSH_OPTIONS

# Banner display
show_banner() {
    echo -e "${CYAN}###########################################################${NC}
${GREEN}# Neutron v10 - Refactored Clean Code Version${NC}
# Lightweight and Powerful automation tool for Linux/Unix
# Page: www.farukguler.com github.com/faruk-guler
# Author: faruk-guler

${YELLOW}Neutron Usage:${NC}
${GREEN}cd <directory>${NC}          : Change directory on all remote hosts
${GREEN}put <local_path> [path]${NC} : Upload file/directory to all remote hosts (parallel)
${GREEN}get <remote_path> [dir]${NC} : Download file/directory from all remote hosts (parallel)
${GREEN}<any_shell_cmd>${NC}         : Run shell command on all remote hosts
${RED}exit${NC}                    : Exit Neutron
${CYAN}###########################################################${NC}"
}

# Utility functions
log_info() {
    echo -e "${BLUE}$1${NC}" >&2
}

log_success() {
    echo -e "${GREEN}$1${NC}" >&2
}

log_warning() {
    echo -e "${YELLOW}$1${NC}" >&2
}

log_error() {
    echo -e "${RED}$1${NC}" >&2
}

# Parse host:port format
parse_host_port() {
    local host_port_entry="$1"
    local -n host_ref=$2
    local -n port_ref=$3
    
    IFS=: read -r host_ref port_ref <<< "$host_port_entry"
}

# Parse command and arguments (simplified)
parse_command_args() {
    local cmd="$1"
    echo "${cmd%% *}" "${cmd#* }"
}

# Load and validate configuration
load_configuration() {
    # Load configuration files
    if ! source config.ntr 2>/dev/null; then
        log_error "Error: config.ntr not found! Please create it and enter your SSH credentials."
        exit 1
    fi
    
    if ! source sources.ntr 2>/dev/null; then
        log_error "Error: sources.ntr not found! Please create it and enter your server list."
        exit 1
    fi
    
    # Validate required variables
    [[ -z "${HOSTS+x}" ]] && { log_error "Error: HOSTS not defined in sources.ntr"; exit 1; }
    [[ -z "${USER+x}" ]] && { log_error "Error: USER not defined in config.ntr"; exit 1; }
    
    # Set configuration defaults
    NEUTRON_CONNECT_TIMEOUT=${NEUTRON_CONNECT_TIMEOUT:-$DEFAULT_CONNECT_TIMEOUT}
    NEUTRON_QUICK_TIMEOUT=${NEUTRON_QUICK_TIMEOUT:-$DEFAULT_QUICK_TIMEOUT}
    NEUTRON_CONTROL_PERSIST=${NEUTRON_CONTROL_PERSIST:-$DEFAULT_CONTROL_PERSIST}
    NEUTRON_MAX_POOL_SIZE=${NEUTRON_MAX_POOL_SIZE:-$DEFAULT_MAX_POOL_SIZE}
    NEUTRON_SSH_OPTIONS=${NEUTRON_SSH_OPTIONS:-$DEFAULT_SSH_OPTIONS}
}

# Private key validation
validate_private_key() {
    local key_file="$1"

    if [[ -z "$key_file" ]]; then
        log_error "Error: PRIVATE_KEY_FILE not specified in config.ntr"
        return 1
    fi

    if [[ ! -f "$key_file" ]]; then
        log_error "Error: Private key file '$key_file' does not exist"
        return 1
    fi

    if [[ ! -r "$key_file" ]]; then
        log_error "Error: Private key file '$key_file' is not readable"
        return 1
    fi

    # Check file permissions
    local perms=$(stat -c "%a" "$key_file" 2>/dev/null)
    if [[ "$perms" != "600" && "$perms" != "400" ]]; then
        log_warning "Warning: Private key file permissions should be 600 or 400 (current: $perms)"
    fi

    # Validate key format
    if ! ssh-keygen -l -f "$key_file" >/dev/null 2>&1; then
        log_error "Error: Invalid private key format in '$key_file'"
        return 1
    fi

    return 0
}

# SSH master options builder
get_ssh_master_options() {
    echo "-o ControlMaster=auto -o ControlPath=$g_ssh_control_path -o ControlPersist=$NEUTRON_CONTROL_PERSIST"
}

# SSH command builder
build_ssh_command() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"
    local timeout="${4:-$NEUTRON_QUICK_TIMEOUT}"

    echo "ssh $(get_ssh_master_options) $options -o ConnectTimeout=$timeout $NEUTRON_SSH_OPTIONS -p $port -i $PRIVATE_KEY_FILE $USER@$host_or_ip"
}

# SCP command builder
build_scp_command() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"

    echo "scp $(get_ssh_master_options) $options -P $port $NEUTRON_SSH_OPTIONS -i $PRIVATE_KEY_FILE"
}

# Execute SSH command wrapper
execute_ssh_command() {
    local host_or_ip="$1"
    local port="$2"
    local command="$3"
    local options="$4"
    local timeout="$5"
    
    local ssh_cmd=$(build_ssh_command "$host_or_ip" "$port" "$options" "$timeout")
    $ssh_cmd "$command"
}

# SSH multiplexing setup
setup_ssh_multiplexing() {
    local host_or_ip="$1"
    local port="$2"
    
    mkdir -p "$HOME/.ssh" 2>/dev/null
    
    # Check if master connection exists
    if ! ssh -O check -o ControlPath="$g_ssh_control_path" "$USER@$host_or_ip" >/dev/null 2>&1; then
        local ssh_cmd=$(build_ssh_command "$host_or_ip" "$port" "-N -f" "$NEUTRON_CONNECT_TIMEOUT")
        
        if $ssh_cmd >/dev/null 2>&1; then
            log_success "SSH multiplexing established for $host_or_ip"
        else
            log_warning "Warning: Could not establish SSH multiplexing for $host_or_ip"
        fi
    fi
}

# Connection pool management
initialize_connection_pool() {
    log_info "Initializing SSH connection pool..."
    
    for host_port_entry in "${HOSTS[@]}"; do
        local host_or_ip port
        parse_host_port "$host_port_entry" host_or_ip port
        
        setup_ssh_multiplexing "$host_or_ip" "$port"
        
        g_connection_pool["$host_or_ip"]="active"
        ((g_connection_pool_size++))
    done
    
    log_success "Connection pool initialized with $g_connection_pool_size hosts"
}

# Fetch hostname for display (lazy loading)
get_hostname() {
    local host_or_ip="$1"
    
    # Return cached hostname if exists
    if [[ -n "${g_host_names[$host_or_ip]}" ]]; then
        echo "${g_host_names[$host_or_ip]}"
        return
    fi
    
    # Fetch and cache hostname
    local port="${g_host_ports[$host_or_ip]}"
    local hostname=$(execute_ssh_command "$host_or_ip" "$port" "hostname" "-n" 2>/dev/null)
    
    hostname="${hostname:-$host_or_ip}"
    g_host_names["$host_or_ip"]="$hostname"
    echo "$hostname"
}

# Initialize session data (simplified)
initialize_session_data() {
    for host_port_entry in "${HOSTS[@]}"; do
        local host_or_ip port
        parse_host_port "$host_port_entry" host_or_ip port
        
        g_current_dir["$host_or_ip"]="/tmp"
        g_host_ports["$host_or_ip"]="$port"
        # Hostname will be fetched lazily when needed
    done
}

# Cleanup SSH connections
cleanup_ssh_connections() {
    log_info "Cleaning up SSH connections..."
    
    for host_or_ip in "${!g_connection_pool[@]}"; do
        ssh -O exit -o ControlPath="$g_ssh_control_path" "$USER@$host_or_ip" >/dev/null 2>&1
    done
    
    rm -f "$HOME/.ssh/neutron-"* 2>/dev/null
    log_success "SSH connections cleaned up"
}

# Initialize readline settings
setup_readline() {
    if [[ $- == *i* ]]; then
        bind '"\e[A": history-search-backward'
        bind '"\e[B": history-search-forward'
        bind 'set show-all-if-ambiguous on'
        bind 'set completion-ignore-case on'
        bind 'TAB: menu-complete'
    fi
}

# Command handlers
handle_cd_command() {
    local args="$1"
    local dir="${args:-$HOME}"
    
    for host_or_ip in "${!g_current_dir[@]}"; do
        local port="${g_host_ports[$host_or_ip]}"
        
        if execute_ssh_command "$host_or_ip" "$port" "test -d \"$dir\" && cd \"$dir\""; then
            g_current_dir["$host_or_ip"]="$dir"
        else
            log_warning "Warning: Directory $dir does not exist or could not be changed on ${g_host_names[$host_or_ip]}"
        fi
    done
}

handle_put_command() {
    local args="$1"
    read -ra tokens <<< "$args"
    local local_path="${tokens[0]}"
    local remote_path="${tokens[1]:-/tmp}"
    
    [[ ! -e "$local_path" ]] && { log_error "Error: Local path $local_path does not exist."; return 1; }
    
    unset g_jobs; declare -A g_jobs
    local scp_option=$([[ -d "$local_path" ]] && echo "-r" || echo "")
    
    for host_or_ip in "${!g_current_dir[@]}"; do
        local port="${g_host_ports[$host_or_ip]}"
        log_info "Uploading $local_path to $(get_hostname "$host_or_ip"):$remote_path"
        
        $(build_scp_command "$host_or_ip" "$port" "") $scp_option "$local_path" "$USER@$host_or_ip:$remote_path" &
        g_jobs["$host_or_ip"]="$!"
    done
    
    wait_for_jobs "upload" "$local_path"
}

handle_get_command() {
    local args="$1"
    read -ra tokens <<< "$args"
    local remote_path="${tokens[0]}"
    local local_dir="${tokens[1]:-./downloads}"
    
    mkdir -p "$local_dir" 2>/dev/null || { log_error "Error: Cannot create directory $local_dir"; return 1; }
    
    unset g_jobs; declare -A g_jobs
    
    for host_or_ip in "${!g_current_dir[@]}"; do
        local port="${g_host_ports[$host_or_ip]}"
        local hostname=$(get_hostname "$host_or_ip")
        local target_dir="$local_dir/$hostname"
        
        log_info "Downloading $remote_path from $hostname to $local_dir/"
        mkdir -p "$target_dir" 2>/dev/null || { log_error "Cannot create directory $target_dir"; continue; }
        
        local scp_cmd=$(build_scp_command "$host_or_ip" "$port" "")
        local is_dir=$(execute_ssh_command "$host_or_ip" "$port" "[ -d \"$remote_path\" ] && echo 'yes' || echo 'no'" 2>/dev/null)
        
        if [[ "$is_dir" == "yes" ]]; then
            $scp_cmd -r "$USER@$host_or_ip:$remote_path" "$target_dir" &
        else
            $scp_cmd "$USER@$host_or_ip:$remote_path" "$target_dir/$(basename "$remote_path")" &
        fi
        
        g_jobs["$host_or_ip"]="$!"
    done
    
    wait_for_jobs "download" "$remote_path"
}

handle_shell_command() {
    local command="$1"
    
    # Clear previous jobs and outputs
    unset g_jobs g_outputs
    declare -A g_jobs g_outputs
    
    for host_or_ip in "${!g_current_dir[@]}"; do
        local port="${g_host_ports[$host_or_ip]}"
        local temp_file=$(mktemp)
        g_outputs["$host_or_ip"]="$temp_file"
        
        local remote_cmd="cd \"${g_current_dir[$host_or_ip]}\" && $command"
        execute_ssh_command "$host_or_ip" "$port" "$remote_cmd" "-n" > "$temp_file" 2>&1 &
        g_jobs["$host_or_ip"]="$!"
    done
    
    # Display results
    display_command_results
}

# Wait for background jobs to complete
wait_for_jobs() {
    local operation="$1"
    local path="$2"
    
    for host_or_ip in "${!g_jobs[@]}"; do
        local hostname="${g_host_names[$host_or_ip]}"
        
        if wait "${g_jobs[$host_or_ip]}"; then
            log_success "Successfully ${operation}ed $path to/from $hostname"
        else
            log_error "Failed to ${operation} $path to/from $hostname"
        fi
    done
}

# Display command execution results
display_command_results() {
    local first_output_block=true
    
    for host_or_ip in "${!g_jobs[@]}"; do
        local wait_status=0
        wait "${g_jobs[$host_or_ip]}" || wait_status=$?
        
        local hostname="${g_host_names[$host_or_ip]}"
        local temp_file="${g_outputs[$host_or_ip]}"
        
        mapfile -t lines < "$temp_file"
        
        # Display output if exists or command failed
        if [[ ${#lines[@]} -gt 0 ]] || [[ $wait_status -ne 0 ]]; then
            if ! $first_output_block; then
                echo ""
            fi
            
            echo -e "${BLUE}host: $hostname${NC}"
            echo -e "${BLUE}--------------------------------------------${NC}"
            
            if [[ ${#lines[@]} -gt 0 ]]; then
                printf "%s\n" "${lines[@]}"
            fi
            
            echo -e "${RED}--------------------------------------------${NC}"
            first_output_block=false
        fi
        
        rm -f "$temp_file"
    done
}

# Command dispatcher
dispatch_command() {
    local cmd="$1"
    local parsed=($(parse_command_args "$cmd"))
    local command_type="${parsed[0]}"
    local args="${parsed[1]}"
    
    case "$command_type" in
        "cd")
            handle_cd_command "$args"
            ;;
        "put")
            handle_put_command "$args"
            ;;
        "get")
            handle_get_command "$args"
            ;;
        *)
            handle_shell_command "$cmd"
            ;;
    esac
}

# Main execution loop
main_loop() {
    while read -e -p "$(echo -e "${GREEN}shell # ${NC}")" -r cmd; do
        # Handle history
        history -s "$cmd"
        history -w "$g_history_file"
        
        # Skip empty commands
        [[ -z "$cmd" ]] && continue
        
        # Handle exit
        [[ "$cmd" == "exit" ]] && break
        
        # Dispatch command
        dispatch_command "$cmd"
    done
}

# Main function
main() {
    # Show banner
    show_banner
    
    # Initialize history file
    touch "$g_history_file"
    
    # Setup readline
    setup_readline
    
    # Load and validate configuration
    load_configuration
    
    # Validate private key
    if ! validate_private_key "$PRIVATE_KEY_FILE"; then
        exit 1
    fi
    
    # Initialize connection pool
    initialize_connection_pool
    
    # Initialize session data
    initialize_session_data
    
    # Setup cleanup trap
    trap 'rm -f "${g_outputs[@]}"; cleanup_ssh_connections' EXIT
    
    # Load command history
    history -r "$g_history_file"
    
    # Start main loop
    main_loop
}

# Run main function
main "$@"
