#!/bin/bash

# Color definitions
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Banner
echo -e "${CYAN}###########################################################${NC}
${GREEN}# Neutron Automation v8 (Secure Mode)${NC}
# Lightweight and Powerful automation tool for Linux/Unix
# Author: faruk-guler
# Page: www.farukguler.com github.com/faruk-guler
${CYAN}###########################################################${NC}"

# History file
HISTORY_FILE="$HOME/.neutron_history"
touch "$HISTORY_FILE"

# Readline settings (for interactive shell)
if [[ $- == *i* ]]; then
    bind '"\e[A": history-search-backward'
    bind '"\e[B": history-search-forward'
    bind 'set show-all-if-ambiguous on'
    bind 'set completion-ignore-case on'
    bind 'TAB: menu-complete'
fi

# Load configuration files
source config.ner || { echo -e "${RED}Error: config.ner not found! Please create it and enter your SSH credentials.${NC}"; exit 1; }
source sources.ner || { echo -e "${RED}Error: sources.ner not found! Please create it and enter your server list.${NC}"; exit 1; }

# Validate configuration
validate_config() {
    [ -z "${HOSTS+x}" ] && { echo -e "${RED}Error: HOSTS not defined in sources.ner${NC}"; exit 1; }
    [ -z "${USER+x}" ] && { echo -e "${RED}Error: USER not defined in config.ner${NC}"; exit 1; }
    [ -z "${PRIVATE_KEY_FILE+x}" ] && { echo -e "${RED}Error: PRIVATE_KEY_FILE not defined in config.ner${NC}"; exit 1; }
    [ ! -f "$PRIVATE_KEY_FILE" ] && { echo -e "${RED}Error: Private key file not found: $PRIVATE_KEY_FILE${NC}"; exit 1; }
    [ -z "${DEFAULT_PORT+x}" ] && { echo -e "${RED}Error: DEFAULT_PORT not defined in config.ner${NC}"; exit 1; }
    [[ ! "$DEFAULT_PORT" =~ ^[0-9]+$ ]] && { echo -e "${RED}Error: DEFAULT_PORT must be a valid number in config.ner${NC}"; exit 1; }
}

# Validate host format
validate_hosts() {
    local invalid_hosts=()
    local -a updated_hosts=()
    for host_port in "${HOSTS[@]}"; do
        if [[ "$host_port" =~ ^[^:]+:[0-9]+$ ]]; then
            updated_hosts+=("$host_port")
        elif [[ "$host_port" =~ ^[^:]+$ ]]; then
            updated_hosts+=("$host_port:$DEFAULT_PORT")
            echo -e "${YELLOW}[INFO] No port specified for $host_port, using default port $DEFAULT_PORT${NC}"
        else
            invalid_hosts+=("$host_port")
        fi
    done
    
    if [ ${#invalid_hosts[@]} -gt 0 ]; then
        echo -e "${RED}Error: Invalid host formats: ${invalid_hosts[*]}${NC}"
        exit 1
    fi
    HOSTS=("${updated_hosts[@]}")
}

# Build SSH command
build_ssh_command() {
    local host="$1"
    local port="$2"
    local additional_opts="${3:-}"
    
    echo "ssh $additional_opts -o ConnectTimeout=3 -o StrictHostKeyChecking=yes -p \"$port\" -i \"$PRIVATE_KEY_FILE\" \"$USER@$host\""
}

# Add host key to known_hosts after validation
add_known_host_secure() {
    local host="$1"
    local port="$2"
    local known_hosts="$HOME/.ssh/known_hosts"
    local temp_file=$(mktemp)

    echo -e "${YELLOW}[INFO] Fetching SSH key for [$host]:$port...${NC}"

    # Get the host key
    ssh-keyscan -p "$port" "$host" 2>/dev/null > "$temp_file"

    if [ $? -ne 0 ] || [ ! -s "$temp_file" ]; then
        echo -e "${RED}[ERROR] Could not retrieve SSH key for [$host]:$port${NC}"
        rm -f "$temp_file"
        return 1
    fi

    echo -e "${CYAN}[KEY] Retrieved key:${NC}"
    cat "$temp_file"

    # Validate key format
    if ! ssh-keygen -lf "$temp_file" >/dev/null 2>&1; then
        echo -e "${RED}[ERROR] Invalid SSH key format for [$host]:$port${NC}"
        rm -f "$temp_file"
        return 1
    fi

    # Check if already exists in known_hosts
    if ssh-keygen -F "[$host]:$port" -f "$known_hosts" >/dev/null; then
        echo -e "${YELLOW}[INFO] [$host]:$port already exists in known_hosts${NC}"
        rm -f "$temp_file"
        return 0
    fi

    # Ask user confirmation before adding
    read -p $'\n'"[CONFIRM] Add this key to known_hosts? (y/n): " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        cat "$temp_file" >> "$known_hosts"
        echo -e "${GREEN}[SUCCESS] Added [$host]:$port to known_hosts${NC}"
    else
        echo -e "${YELLOW}[CANCEL] Key for [$host]:$port was NOT added${NC}"
    fi

    rm -f "$temp_file"
}

# Execute validation
validate_config
validate_hosts

# Initialize session data
declare -A current_dir host_ports

for host_port in "${HOSTS[@]}"; do
    IFS=: read -r host port <<< "$host_port"
    current_dir["$host"]="/root"
    host_ports["$host"]="$host:$port"
done

# Add known hosts securely
for host_port in "${HOSTS[@]}"; do
    IFS=: read -r host port <<< "$host_port"
    add_known_host_secure "$host" "$port"
done

# Inform user about manual known_hosts setup (optional)
# echo -e "${YELLOW}[SECURITY] Please ensure all hosts are manually added to ~/.ssh/known_hosts before use.${NC}"
# echo -e "${YELLOW}[INFO] You can use 'ssh-keyscan' or 'ssh' command to verify and add keys securely.${NC}"

# Clean up temporary files on exit
trap 'for tmp in "${outputs[@]}"; do rm -f "$tmp" 2>/dev/null; done' EXIT

# Load command history
history -r "$HISTORY_FILE"

# Main loop
while read -e -p "$(echo -e "${GREEN}shell # ${NC}")" -r cmd; do
    history -s "$cmd"
    history -w "$HISTORY_FILE"

    [ -z "$cmd" ] && continue
    [ "$cmd" = "exit" ] && break

    # Handle "cd" command
    if [[ "$cmd" =~ ^cd ]]; then
        dir="${cmd#cd }"
        [ -z "$dir" ] && dir="~"
        
        for host in "${!current_dir[@]}"; do
            IFS=: read -r _ port <<< "${host_ports[$host]}"
            ssh_cmd=$(build_ssh_command "$host" "$port")
            
            if $ssh_cmd "test -d \"$dir\""; then
                current_dir["$host"]="$dir"
            else
                echo -e "${YELLOW}Warning: Directory '$dir' does not exist on $host${NC}"
            fi
        done
        continue
    fi

    # Handle all other commands
    declare -A jobs outputs

    for host in "${!current_dir[@]}"; do
        IFS=: read -r _ port <<< "${host_ports[$host]}"
        temp_file=$(mktemp)
        outputs["$host"]="$temp_file"

        ssh_cmd=$(build_ssh_command "$host" "$port" "-n")
        remote_cmd="cd \"${current_dir[$host]}\" && hostname && $cmd"
        
        $ssh_cmd "bash -c \"$remote_cmd\"" > "$temp_file" 2>&1 &
        jobs["$host"]="$!"
    done

    first=true
    for host in "${!jobs[@]}"; do
        wait "${jobs[$host]}"

        if ! $first; then
            echo ""
        fi

        echo -e "${BLUE}----------- $host -----------${NC}"
        if [ -s "${outputs[$host]}" ]; then
            mapfile -t lines < "${outputs[$host]}"
            if [ ${#lines[@]} -gt 0 ]; then
                echo -e "${GREEN}${lines[0]} ${CYAN}#${NC}"
                printf "%s\n" "${lines[@]:1}"
            fi
        else
            echo -e "${RED}No output or connection failed${NC}"
        fi
        echo -e "${BLUE}--------------------------------------------${NC}"
        rm "${outputs[$host]}" 2>/dev/null
        first=false
    done
done
