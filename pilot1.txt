#!/usr/bin/env python3
import yaml
import paramiko
import colorama
import os
import sys
from typing import List, Dict
from concurrent.futures import ThreadPoolExecutor

# Initialize colorama for cross-platform terminal colors
colorama.init(autoreset=True)


class LinuxSSHTool:
    def __init__(self):
        self.config = self.load_config()
        self.servers = self.load_servers()

    def load_config(self) -> Dict:
        """
        config.cfg dosyasından SSH yapılandırmasını okur:
          - Dosya boş veya hatalı ise hata verir.
          - SSH kullanıcı adı, kimlik doğrulama yöntemi (key_path veya password) kontrol edilir.
          - Paralel çalıştırma için max_workers (varsayılan 10) değeri ayarlanır.
        """
        try:
            with open('config.cfg') as f:
                config = yaml.safe_load(f)
            if not config:
                raise ValueError("config.cfg is empty or invalid.")

            ssh_config = config.get('ssh')
            if not ssh_config or not ssh_config.get('user'):
                raise ValueError("Invalid config.cfg: SSH user is not defined.")

            # Hem key_path hem de password aynı anda verilemez
            if ssh_config.get('key_path') and ssh_config.get('password'):
                raise ValueError("Please provide either a key_path or password, not both.")

            # Kimlik doğrulama yöntemi belirtilmediyse hata verir
            if not ssh_config.get('key_path') and not ssh_config.get('password'):
                raise ValueError("No authentication method provided: Define either key_path or password.")

            ssh_config['max_workers'] = ssh_config.get('max_workers', 10)
            ssh_config['port'] = ssh_config.get('port', 22)
            return ssh_config

        except Exception as e:
            print(f"{colorama.Fore.RED}[ERROR] Failed to load config: {e}")
            sys.exit(1)

    def load_servers(self) -> List[Dict]:
        """
        source.yaml dosyasından sunucu listesini okur:
          - Her sunucu için host ve port doğrulanır.
        """
        try:
            with open('source.yaml') as f:
                data = yaml.safe_load(f)
            if not data:
                raise ValueError("source.yaml is empty or invalid.")
            servers = data.get('servers', [])

            normalized = []
            for s in servers:
                if isinstance(s, str):
                    if not s.strip():
                        raise ValueError("Empty host provided in source.yaml")
                    normalized.append({'host': s.strip(), 'port': self.config.get('port', 22)})
                elif isinstance(s, dict):
                    host = s.get('host')
                    if not host or not host.strip():
                        raise ValueError("Invalid or empty host in source.yaml")
                    port = s.get('port', self.config.get('port', 22))
                    if not isinstance(port, int) or port <= 0 or port > 65535:
                        raise ValueError(f"Invalid port for host {host}: {port}")
                    normalized.append({'host': host.strip(), 'port': port})
                else:
                    raise ValueError("Server items must be either string or dict.")
            return normalized

        except Exception as e:
            print(f"{colorama.Fore.RED}[ERROR] Failed to load server list: {e}")
            sys.exit(1)

    def run_command(self, host: str, port: int, command: str):
        """
        Uzak ana bilgisayara SSH bağlantısı kurar ve komutu çalıştırır.
        get_pty=True parametresi sayesinde terminal bağımlı komutlar (ör. clear) normal şekilde yürütülür.
        Klasik SSH araçlarındaki gibi; komut çıktı üretmiyorsa sessizce geçer.
        """
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            print(f"\n{colorama.Fore.CYAN}🔹 Connecting to {host}:{port}")
            print(f"   {colorama.Fore.YELLOW}$ {command}")

            connect_params = {
                'hostname': host,
                'port': port,
                'username': self.config['user'],
            }
            if self.config.get('key_path'):
                connect_params['key_filename'] = os.path.expanduser(self.config['key_path'])
            elif self.config.get('password'):
                connect_params['password'] = self.config['password']

            ssh.connect(**connect_params)

            # get_pty=True ile terminal ortamı sağlanıyor.
            stdin, stdout, stderr = ssh.exec_command(command, timeout=30, get_pty=True)
            output = stdout.read().decode().strip()
            error = stderr.read().decode().strip()

            # Klasik SSH'da, çıktı olmayan komutlar için hiçbir mesaj gösterilmez.
            if output:
                print(f"{colorama.Fore.GREEN}   ✅ Output:\n{output}")
            if error:
                print(f"{colorama.Fore.RED}   ❗ Error:\n{error}")

        except Exception as e:
            print(f"{colorama.Fore.RED}   ❌ Connection error on {host}: {e}")
        finally:
            ssh.close()

    def execute_task(self, task_file: str):
        """
        Bir YAML dosyasındaki komut listesini tüm sunucularda paralel olarak yürütür.
        Örnek task dosyası içeriği:
            commands:
              - "clear"
              - "reset"
              - "cd /tmp"
              - "ls -l"
        """
        try:
            with open(task_file) as f:
                task_data = yaml.safe_load(f)
            if not task_data:
                raise ValueError("Task file is empty or invalid.")
            commands = task_data.get('commands', [])
            if not commands:
                raise ValueError("No commands defined in the task file.")

            max_workers = self.config.get('max_workers', 10)
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = []
                for server in self.servers:
                    for cmd in commands:
                        futures.append(
                            executor.submit(self.run_command, server['host'], server['port'], cmd)
                        )
                for future in futures:
                    future.result()

        except Exception as e:
            print(f"{colorama.Fore.RED}[ERROR] Task execution failed: {e}")

    def interactive_mode(self):
        """
        İnteraktif mod: Kullanıcı terminalden komut girerek tüm sunucularda çalıştırabilir.
        'exit' veya 'quit' girildiğinde çıkış yapılır.
        Not: Her komut ayrı bir SSH oturumu açtığından, ortam değiştiren (ör. cd) 
        komutların etkisi sonraki komutlara yansımaz.
        """
        print(f"{colorama.Fore.MAGENTA}#######################################################################")
        print(f"{colorama.Fore.MAGENTA}###                            NEUTRON                              ###")
        print(f"{colorama.Fore.MAGENTA}### 🐧Lightweight automation tool for Linux (Type 'exit' to quit)   ###")
        print(f"{colorama.Fore.MAGENTA}###                     www.farukguler.com                          ###")
        print(f"{colorama.Fore.MAGENTA}#######################################################################")

        while True:
            try:
                cmd = input(f"{colorama.Fore.CYAN}\nssh> ").strip()
                if cmd.lower() in ['exit', 'quit']:
                    break

                max_workers = self.config.get('max_workers', 10)
                with ThreadPoolExecutor(max_workers=max_workers) as executor:
                    futures = []
                    for server in self.servers:
                        futures.append(
                            executor.submit(self.run_command, server['host'], server['port'], cmd)
                        )
                    for future in futures:
                        future.result()

            except KeyboardInterrupt:
                print(f"{colorama.Fore.RED}\nExiting...")
                break


if __name__ == "__main__":
    tool = LinuxSSHTool()
    if len(sys.argv) > 1:
        tool.execute_task(sys.argv[1])
    else:
        tool.interactive_mode()
