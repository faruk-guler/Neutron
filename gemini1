#!/bin/bash

# Color definitions
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Banner
echo -e "${CYAN}###########################################################${NC}
${GREEN}# Neutron v10 - Enhanced Edition${NC}
# Lightweight and Powerful automation tool for Linux/Unix
# Page: www.farukguler.com github.com/faruk-guler
# Author: faruk-guler
#
${YELLOW}Usage:${NC}
${GREEN}cd <directory>${NC}       : Change directory on all remote hosts
${GREEN}put <local_path> [path]${NC} : Upload file/directory to all remote hosts (parallel)
${GREEN}get <remote_path> [dir]${NC} : Download file/directory from all remote hosts (parallel)
${GREEN}<any_shell_cmd>${NC}        : Run shell command on all remote hosts
${GREEN}exit${NC}                 : Exit Neutron
${CYAN}###########################################################${NC}"

# History file
HISTORY_FILE="$HOME/.neutron_history"
touch "$HISTORY_FILE"

# Readline settings (for interactive shell)
if [[ $- == *i* ]]; then
    bind '"\e[A": history-search-backward' # Up arrow: search history backward
    bind '"\e[B": history-search-forward'  # Down arrow: search history forward
    bind 'set show-all-if-ambiguous on'
    bind 'set completion-ignore-case on'
    bind 'TAB: menu-complete'
fi

# Load configuration files
source config.ntr || { echo -e "${RED}Error: config.ntr not found! Please create it and enter your SSH credentials.${NC}"; exit 1; }
source sources.ntr || { echo -e "${RED}Error: sources.ntr not found! Please create it and enter your server list.${NC}"; exit 1; }

[ -z "${HOSTS+x}" ] && { echo -e "${RED}Error: HOSTS not defined in sources.ntr${NC}" >&2; exit 1; }
[ -z "${USER+x}" ] && { echo -e "${RED}Error: USER not defined in config.ntr${NC}" >&2; exit 1; }

# Global array to store temporary output files
declare -a TEMP_OUTPUT_FILES

# Clean up temporary files on exit or signal
cleanup_temp_files() {
    if [ ${#TEMP_OUTPUT_FILES[@]} -gt 0 ]; then
        echo -e "${YELLOW}Cleaning up temporary files...${NC}" >&2
        rm -f "${TEMP_OUTPUT_FILES[@]}"
        unset TEMP_OUTPUT_FILES # Clear the array
    fi
}

# Trap signals for cleanup
trap cleanup_temp_files EXIT INT TERM

# Private key validation function
validate_private_key() {
    local key_file="$1"
    
    if [ -z "$key_file" ]; then
        echo -e "${RED}Error: PRIVATE_KEY_FILE not specified in config.ntr${NC}" >&2
        return 1
    fi
    
    if [ ! -f "$key_file" ]; then
        echo -e "${RED}Error: Private key file '$key_file' does not exist${NC}" >&2
        return 1
    fi
    
    if [ ! -r "$key_file" ]; then
        echo -e "${RED}Error: Private key file '$key_file' is not readable${NC}" >&2
        return 1
    fi
    
    # Check file permissions (should be 600 or 400)
    local perms=$(stat -c "%a" "$key_file" 2>/dev/null)
    if [[ "$perms" != "600" && "$perms" != "400" ]]; then
        echo -e "${YELLOW}Warning: Private key file permissions should be 600 or 400 (current: $perms)${NC}" >&2
    fi
    
    # Validate key format
    if ! ssh-keygen -l -f "$key_file" >/dev/null 2>&1; then
        echo -e "${RED}Error: Invalid private key format in '$key_file'${NC}" >&2
        return 1
    fi
    
    return 0
}

# Validate private key once at startup
if ! validate_private_key "$PRIVATE_KEY_FILE"; then
    exit 1
fi

# SSH command builder function (to avoid repetition)
build_ssh_cmd() {
    local host="$1"
    local port="$2"
    local options="$3"
    
    # It's generally safer to include StrictHostKeyChecking=no only if explicitly requested,
    # or to manage known_hosts file. For this script's current design, keeping it for simplicity.
    echo "ssh $options -o ConnectTimeout=3 -o StrictHostKeyChecking=no -p \"$port\" -i \"$PRIVATE_KEY_FILE\" \"$USER@$host\""
}

# SCP command builder function
build_scp_cmd() {
    local host="$1"
    local port="$2"
    local options="$3"
    
    echo "scp $options -P \"$port\" -o StrictHostKeyChecking=no -i \"$PRIVATE_KEY_FILE\""
}

# Initialize session data
declare -A current_dir host_ports

for host_port in "${HOSTS[@]}"; do
    IFS=: read host port <<< "$host_port"
    current_dir["$host"]="/root" # Default remote directory
    host_ports["$host"]="$host:$port"
done

# Load command history
history -r "$HISTORY_FILE"

# Main loop
while read -e -p "$(echo -e "${GREEN}shell # ${NC}")" -r cmd; do
    history -s "$cmd"
    history -w "$HISTORY_FILE"

    [ -z "$cmd" ] && continue
    [ "$cmd" = "exit" ] && break

    # Handle "cd" command with path validation
    if [[ "$cmd" =~ ^cd\s+ ]]; then
        local_dir_arg="${cmd#cd }"
        
        # Basic path validation: Prevent '..' and '/' at the beginning for security
        # This prevents simple path traversal attempts like `cd ../../../etc`
        # and absolute path override for `cd /tmp` if not explicitly desired by current_dir logic
        if [[ "$local_dir_arg" == *'..'* ]] || [[ "$local_dir_arg" == '/'* ]]; then
             echo -e "${RED}Error: Path traversal attempts or absolute paths are not allowed for 'cd'. Use relative paths only (e.g., 'cd mydir', 'cd somedir/subdir').${NC}"
             continue
        fi

        for host in "${!current_dir[@]}"; do
            IFS=: read _ port <<< "${host_ports[$host]}"
            ssh_cmd=$(build_ssh_cmd "$host" "$port" "")

            # Construct the new path safely by resolving '..' if it somehow bypasses initial check
            # Use 'realpath -m' for canonical path, but only for local verification.
            # On remote, we rely on `cd` to handle relative paths.
            # To handle relative paths correctly and prevent ".." traversal to parent directories outside scope:
            # We first cd to current_dir, then attempt to cd to the user's provided relative path.
            # This ensures operations stay within the expected hierarchy.
            # If the user provides `cd some/dir` it's relative to current_dir.
            
            # The core vulnerability of path traversal is in *constructing* the final path
            # without proper sanitization. By only allowing relative path segments and
            # letting the remote shell handle the `cd` command, we limit the direct injection risk.
            # The `test -d` will fail if the path goes outside the intended scope.
            
            # For `cd`, the new_remote_path logic is crucial:
            # The shell itself handles '..' within the `cd` command.
            # What we need to prevent is an initial "jump" to a completely different part of the filesystem
            # or traversing multiple directories up.
            # My current validation prevents leading '/' and '..' as a direct component.
            # If `cd mydir/../anotherdir` is used, the shell will resolve it. This is fine.
            # The issue is `cd ../../../etc/passwd` being processed directly.
            # By only setting `current_dir["$host"]` IF `test -d` is successful,
            # and `local_dir_arg` not starting with `/` or containing `..`,
            # we ensure that the new current_dir is always a sub-directory or sibling
            # of the existing current_dir, not an arbitrary path.

            # Test if the combined path exists and is a directory
            # For relative paths, we need to carefully construct the target path for verification
            # `current_dir["$host"]` is an absolute path. `local_dir_arg` is a relative path.
            # We want to go to `current_dir["$host"]/local_dir_arg`
            
            # Use `printf %q` to safely quote the directory argument for the remote command
            quoted_dir_arg=$(printf %q "$local_dir_arg")
            
            if eval "$ssh_cmd \"cd ${current_dir[$host]} && test -d $quoted_dir_arg\""; then
                # If test is successful, get the absolute path on the remote host
                # Using 'pwd -P' for physical path (resolves symlinks)
                new_remote_path=$(eval "$ssh_cmd \"cd ${current_dir[$host]} && cd $quoted_dir_arg && pwd -P\"")
                if [ $? -eq 0 ]; then
                    current_dir["$host"]="$new_remote_path"
                    echo -e "${GREEN}$host: Changed directory to $new_remote_path${NC}"
                else
                    echo -e "${RED}$host: Failed to determine new path after 'cd ${current_dir[$host]}/$local_dir_arg'${NC}"
                fi
            else
                echo -e "${YELLOW}Warning: Directory '$local_dir_arg' does not exist or is not accessible from '${current_dir[$host]}' on $host.${NC}"
            fi
        done
        continue
    fi

    # Handle "put" command (file or directory) - Parallel SCP
    if [[ "$cmd" =~ ^put\s+ ]]; then
        IFS=' ' read -ra tokens <<< "${cmd#put }"
        local_path="${tokens[0]}"
        remote_dest_path="${tokens[1]}" # Optional remote path
        
        # If remote_dest_path is not provided, use the current_dir on the remote host
        if [ -z "$remote_dest_path" ]; then
            # We cannot use current_dir[$host] directly as scp target without knowing the host
            # For simplicity, if not provided, SCP will put it in the user's home directory on remote.
            # If a specific directory is desired, user must specify.
            # Or, we can modify SCP to target current_dir[$host] for each host.
            # Let's adjust remote_path handling for 'put' to be more explicit.
            echo -e "${RED}Error: For 'put', please specify a destination path on the remote host (e.g., put local_file /tmp/remote_file).${NC}"
            continue
        fi

        if [ ! -e "$local_path" ]; then
            echo -e "${RED}Error: Local path '$local_path' does not exist.${NC}"
            continue
        fi

        declare -A jobs

        for host in "${!current_dir[@]}"; do
            IFS=: read _ port <<< "${host_ports[$host]}"
            host_name=$(echo "${host_ports[$host]}" | cut -d':' -f1)

            echo -e "${GREEN}Uploading '$local_path' to $host_name:'$remote_dest_path'${NC}"

            scp_cmd=$(build_scp_cmd "$host" "$port" "")

            if [ -d "$local_path" ]; then
                eval "$scp_cmd -r \"$local_path\" \"$USER@$host:$remote_dest_path\" &"
            else
                eval "$scp_cmd \"$local_path\" \"$USER@$host:$remote_dest_path\" &"
            fi

            jobs["$host"]="$!"
        done

        # Wait for all transfers to complete
        for host in "${!jobs[@]}"; do
            wait "${jobs[$host]}"
            if [ $? -eq 0 ]; then
                echo -e "${GREEN}Successfully uploaded '$local_path' to $host${NC}"
            else
                echo -e "${RED}Failed to upload '$local_path' to $host${NC}"
            fi
        done

        continue
    fi

    # Handle "get" command (file or directory)
    if [[ "$cmd" =~ ^get\s+ ]]; then
        IFS=' ' read -ra tokens <<< "${cmd#get }"
        remote_path="${tokens[0]}"
        local_dir="${tokens[1]:-./downloads}" # Default local dir is ./downloads

        mkdir -p "$local_dir" 2>/dev/null || {
            echo -e "${RED}Error: Cannot create or access directory '$local_dir'.${NC}"
            continue
        }

        declare -A jobs

        for host in "${!current_dir[@]}"; do
            IFS=: read _ port <<< "${host_ports[$host]}"
            host_name=$(echo "${host_ports[$host]}" | cut -d':' -f1)

            echo -e "${GREEN}Downloading '$remote_path' from $host_name to '$local_dir/'${NC}"

            scp_cmd=$(build_scp_cmd "$host" "$port" "")

            target_host_dir="$local_dir/$host_name"
            mkdir -p "$target_host_dir" 2>/dev/null || {
                echo -e "${RED}Error: Cannot create directory '$target_host_dir' for $host.${NC}"
                continue
            }
            
            # Determine if remote path is a directory
            # We need to construct the full remote path to check if it's a directory
            # For `get`, remote_path can be absolute or relative to the user's default SSH dir (often home)
            # The original logic used current_dir for all commands. Let's make get respect that.
            
            # Escape remote_path for shell execution
            escaped_remote_path=$(printf %q "$remote_path")
            
            ssh_cmd_check=$(build_ssh_cmd "$host" "$port" "")
            is_dir=$(eval "$ssh_cmd_check \"[ -d $escaped_remote_path ] && echo 'yes' || echo 'no'\"")
            
            if [ "$is_dir" = "yes" ]; then
                # If it's a directory, SCP will put contents into target_host_dir/basename(remote_path)
                eval "$scp_cmd -r \"$USER@$host:$remote_path\" \"$target_host_dir\" &"
            else
                # If it's a file, we specify the exact target filename
                target_file="$target_host_dir/$(basename "$remote_path")"
                eval "$scp_cmd \"$USER@$host:$remote_path\" \"$target_file\" &"
            fi

            jobs["$host"]="$!"
        done

        for host in "${!jobs[@]}"; do
            wait "${jobs[$host]}"
            if [ $? -eq 0 ]; then
                echo -e "${GREEN}Successfully downloaded '$remote_path' from $host${NC}"
            else
                echo -e "${RED}Failed to download '$remote_path' from $host${NC}"
            fi
        done

        continue
    fi

    # Handle all other commands
    declare -A jobs outputs

    for host in "${!current_dir[@]}"; do
        IFS=: read _ port <<< "${host_ports[$host]}"
        temp_file=$(mktemp)
        outputs["$host"]="$temp_file"
        TEMP_OUTPUT_FILES+=( "$temp_file" ) # Add to global cleanup list

        ssh_cmd=$(build_ssh_cmd "$host" "$port" "-n")

        # Commands run in the current directory on the remote host
        # Safely quote the command for the remote shell to prevent injection
        quoted_cmd=$(printf %q "$cmd")
        remote_cmd="cd \"${current_dir[$host]}\" && $quoted_cmd"
        
        eval "$ssh_cmd \"$remote_cmd\" > \"$temp_file\" 2>&1 &"
        jobs["$host"]="$!"
    done

    first_output_block=true
    for host in "${!jobs[@]}"; do
        wait "${jobs[$host]}"
        exit_code=$? # Capture exit code of the remote command

        host_port="${host_ports[$host]}"
        host_name=$(echo "$host_port" | cut -d':' -f1)

        if ! $first_output_block; then
            echo ""
        fi

        echo -e "${BLUE}----------- $host_name -----------${NC}"
        
        # Read all lines from the temp file
        mapfile -t lines < "${outputs[$host]}"
        
        # Check if output is empty
        if [ ${#lines[@]} -eq 0 ]; then
            echo -e "${YELLOW}No output.${NC}"
        else
            # Print all lines without special handling for the first line or '#'
            printf "%s\n" "${lines[@]}"
        fi

        # Indicate command success/failure
        if [ "$exit_code" -eq 0 ]; then
            echo -e "${GREEN}Command completed successfully. (Exit Code: $exit_code)${NC}"
        else
            echo -e "${RED}Command failed. (Exit Code: $exit_code)${NC}"
        fi

        echo -e "${BLUE}--------------------------------------------${NC}"
        
        # This file will be cleaned by the trap handler, no need to rm here.
        # rm "${outputs[$host]}" 
        first_output_block=false
    done
done
