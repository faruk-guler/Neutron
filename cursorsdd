#!/bin/bash

# Color definitions
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly RED='\033[0;31m'
readonly NC='\033[0m'

# Constants
readonly HISTORY_FILE="$HOME/.neutron_history"
readonly SSH_CONTROL_PATH="$HOME/.ssh/neutron-%r@%h:%p"
readonly SSH_MASTER_OPTIONS="-o ControlMaster=auto -o ControlPath=$SSH_CONTROL_PATH -o ControlPersist=60s"
readonly MAX_POOL_SIZE=10

# Banner
print_banner() {
    echo -e "${CYAN}###########################################################${NC}
${GREEN}# Neutron v10 ${NC}
# Lightweight and Powerful automation tool for Linux/Unix
# Page: www.farukguler.com github.com/faruk-guler
# Author: faruk-guler

${YELLOW}Neutron Usage:${NC}
${GREEN}cd <directory>${NC}          : Change directory on all remote hosts
${GREEN}put <local_path> [path]${NC} : Upload file/directory to all remote hosts (parallel)
${GREEN}get <remote_path> [dir]${NC} : Download file/directory from all remote hosts (parallel)
${GREEN}<any_shell_cmd>${NC}         : Run shell command on all remote hosts
${RED}exit${NC}                    : Exit Neutron
${CYAN}###########################################################${NC}"
}

# Initialize history file
touch "$HISTORY_FILE"

# Readline settings
setup_readline() {
    if [[ $- == *i* ]]; then
        bind '"\e[A": history-search-backward'
        bind '"\e[B": history-search-forward'
        bind 'set show-all-if-ambiguous on'
        bind 'set completion-ignore-case on'
        bind 'TAB: menu-complete'
    fi
}

# Load configuration
load_config() {
    source config.ntr || { echo -e "${RED}Error: config.ntr not found! Please create it and enter your SSH credentials.${NC}"; exit 1; }
    source sources.ntr || { echo -e "${RED}Error: sources.ntr not found! Please create it and enter your server list.${NC}"; exit 1; }

    [ -z "${HOSTS+x}" ] && { echo "Error: HOSTS not defined in sources.ntr" >&2; exit 1; }
    [ -z "${USER+x}" ] && { echo "Error: USER not defined in config.ntr" >&2; exit 1; }
}

# Validate private key
validate_private_key() {
    local key_file="$1"

    [ -z "$key_file" ] && { echo -e "${RED}Error: PRIVATE_KEY_FILE not specified in config.ntr${NC}" >&2; return 1; }
    [ ! -f "$key_file" ] && { echo -e "${RED}Error: Private key file '$key_file' does not exist${NC}" >&2; return 1; }
    [ ! -r "$key_file" ] && { echo -e "${RED}Error: Private key file '$key_file' is not readable${NC}" >&2; return 1; }

    local perms=$(stat -c "%a" "$key_file" 2>/dev/null)
    [[ "$perms" != "600" && "$perms" != "400" ]] && echo -e "${YELLOW}Warning: Private key file permissions should be 600 or 400 (current: $perms)${NC}" >&2

    ssh-keygen -l -f "$key_file" >/dev/null 2>&1 || { echo -e "${RED}Error: Invalid private key format in '$key_file'${NC}" >&2; return 1; }
    return 0
}

# SSH connection management
setup_ssh_multiplexing() {
    local host_or_ip="$1"
    local port="$2"

    mkdir -p "$HOME/.ssh" 2>/dev/null

    if ! ssh -O check -o ControlPath="$SSH_CONTROL_PATH" "$USER@$host_or_ip" >/dev/null 2>&1; then
        ssh $SSH_MASTER_OPTIONS \
            -o ConnectTimeout=10 \
            -o StrictHostKeyChecking=no \
            -p "$port" \
            -i "$PRIVATE_KEY_FILE" \
            -N -f \
            "$USER@$host_or_ip" >/dev/null 2>&1 && \
            echo -e "${GREEN}SSH multiplexing established for $host_or_ip${NC}" >&2 || \
            echo -e "${YELLOW}Warning: Could not establish SSH multiplexing for $host_or_ip${NC}" >&2
    fi
}

# Command builders
build_ssh_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"

    echo "$SSH_MASTER_OPTIONS $options -o ConnectTimeout=3 -o StrictHostKeyChecking=no -p $port -i $PRIVATE_KEY_FILE $USER@$host_or_ip"
}

build_scp_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"

    echo "$SSH_MASTER_OPTIONS $options -P $port -o StrictHostKeyChecking=no -i $PRIVATE_KEY_FILE"
}

# Connection pool management
declare -A connection_pool
connection_pool_size=0

init_connection_pool() {
    echo -e "${BLUE}Initializing SSH connection pool...${NC}"

    for host_port_entry in "${HOSTS[@]}"; do
        IFS=: read host_or_ip port <<< "$host_port_entry"
        setup_ssh_multiplexing "$host_or_ip" "$port"
        connection_pool["$host_or_ip"]="active"
        ((connection_pool_size++))
    done

    echo -e "${GREEN}Connection pool initialized with $connection_pool_size hosts${NC}"
}

cleanup_ssh_connections() {
    echo -e "${BLUE}Cleaning up SSH connections...${NC}"

    for host_or_ip in "${!connection_pool[@]}"; do
        ssh -O exit -o ControlPath="$SSH_CONTROL_PATH" "$USER@$host_or_ip" >/dev/null 2>&1
    done

    rm -f "$HOME/.ssh/neutron-"* 2>/dev/null
    echo -e "${GREEN}SSH connections cleaned up${NC}"
}

# Command handlers
handle_cd() {
    local dir="${1#cd }"
    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        local ssh_cmd=($(build_ssh_cmd "$host_or_ip" "$port" ""))

        if ssh "${ssh_cmd[@]}" "test -d \"$dir\" && cd \"$dir\""; then
            current_dir["$host_or_ip"]="$dir"
        else
            echo -e "${YELLOW}Warning: Directory $dir does not exist or could not be changed on ${host_names[$host_or_ip]}.${NC}"
        fi
    done
}

handle_put() {
    local local_path="${1#put }"
    local remote_path="${2:-/tmp}"

    [ ! -e "$local_path" ] && { echo -e "${RED}Error: Local path $local_path does not exist.${NC}"; return; }

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        echo -e "${GREEN}Uploading $local_path to ${host_names[$host_or_ip]}:${remote_path}${NC}"

        local scp_cmd=($(build_scp_cmd "$host_or_ip" "$port" ""))
        if [ -d "$local_path" ]; then
            scp "${scp_cmd[@]}" -r "$local_path" "$USER@$host_or_ip:$remote_path" &
        else
            scp "${scp_cmd[@]}" "$local_path" "$USER@$host_or_ip:$remote_path" &
        fi
        jobs["$host_or_ip"]="$!"
    done

    for host_or_ip in "${!jobs[@]}"; do
        wait "${jobs[$host_or_ip]}"
        [ $? -eq 0 ] && \
            echo -e "${GREEN}Successfully uploaded $local_path to ${host_names[$host_or_ip]}${NC}" || \
            echo -e "${RED}Failed to upload $local_path to ${host_names[$host_or_ip]}${NC}"
    done
}

handle_get() {
    local remote_path="${1#get }"
    local local_dir="${2:-./downloads}"

    mkdir -p "$local_dir" 2>/dev/null || { echo -e "${RED}Error: Cannot create or access directory $local_dir${NC}"; return; }

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        echo -e "${GREEN}Downloading $remote_path from ${host_names[$host_or_ip]} to $local_dir/${NC}"

        local scp_cmd=($(build_scp_cmd "$host_or_ip" "$port" ""))
        local ssh_cmd=($(build_ssh_cmd "$host_or_ip" "$port" ""))

        local target_dir="$local_dir/${host_names[$host_or_ip]}"
        mkdir -p "$target_dir" 2>/dev/null || { echo -e "${RED}Error: Cannot create directory $target_dir for ${host_names[$host_or_ip]}${NC}"; continue; }

        local target_file="$target_dir/$(basename "$remote_path")"
        local is_dir=$(ssh "${ssh_cmd[@]}" "[ -d \"$remote_path\" ] && echo 'yes' || echo 'no'" 2>/dev/null)

        if [ "$is_dir" = "yes" ]; then
            scp "${scp_cmd[@]}" -r "$USER@$host_or_ip:$remote_path" "$target_dir" &
        else
            scp "${scp_cmd[@]}" "$USER@$host_or_ip:$remote_path" "$target_file" &
        fi

        jobs["$host_or_ip"]="$!"
    done

    for host_or_ip in "${!jobs[@]}"; do
        wait "${jobs[$host_or_ip]}"
        [ $? -eq 0 ] && \
            echo -e "${GREEN}Successfully downloaded $remote_path from ${host_names[$host_or_ip]}${NC}" || \
            echo -e "${RED}Failed to download $remote_path from ${host_names[$host_or_ip]}${NC}"
    done
}

handle_command() {
    local cmd="$1"
    local first_output_block=true

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        local temp_file=$(mktemp)
        outputs["$host_or_ip"]="$temp_file"

        local ssh_cmd=($(build_ssh_cmd "$host_or_ip" "$port" "-n"))
        local remote_cmd="cd \"${current_dir[$host_or_ip]}\" && $cmd"

        ssh "${ssh_cmd[@]}" "$remote_cmd" > "$temp_file" 2>&1 &
        jobs["$host_or_ip"]="$!"
    done

    for host_or_ip in "${!jobs[@]}"; do
        wait_status=0
        wait "${jobs[$host_or_ip]}" || wait_status=$?

        local remote_display_name="${host_names[$host_or_ip]}"
        mapfile -t lines < "${outputs[$host_or_ip]}"

        if [ ${#lines[@]} -gt 0 ] || [ $wait_status -ne 0 ]; then
            ! $first_output_block && echo ""
            echo -e "${BLUE}host: ${remote_display_name}${NC}"
            echo -e "${BLUE}--------------------------------------------${NC}"

            [ ${#lines[@]} -gt 0 ] && printf "%s\n" "${lines[@]}"

            echo -e "${RED}--------------------------------------------${NC}"
        fi
        rm "${outputs[$host_or_ip]}"
        first_output_block=false
    done
}

# Initialize hostnames
init_hostnames() {
    for host_port_entry in "${HOSTS[@]}"; do
        IFS=: read host_or_ip port <<< "$host_port_entry"
        current_dir["$host_or_ip"]="/tmp"
        host_ports["$host_or_ip"]="$port"

        local ssh_cmd=($(build_ssh_cmd "$host_or_ip" "$port" "-n"))
        local remote_hostname=$(ssh "${ssh_cmd[@]}" "hostname" 2>/dev/null)

        host_names["$host_or_ip"]="${remote_hostname:-$host_or_ip}"
    done
}

# Main initialization
setup_readline
load_config
validate_private_key "$PRIVATE_KEY_FILE" || exit 1

# Initialize session data
declare -A current_dir host_ports host_names outputs
init_connection_pool
init_hostnames

# Cleanup on exit
trap 'rm -f "${outputs[@]}"; cleanup_ssh_connections' EXIT

# Load command history
history -r "$HISTORY_FILE"

# Main loop
print_banner
while read -e -p "$(echo -e "${GREEN}shell # ${NC}")" -r cmd; do
    history -s "$cmd"
    history -w "$HISTORY_FILE"

    [ -z "$cmd" ] && continue
    [ "$cmd" = "exit" ] && break

    declare -A jobs

    case "$cmd" in
        cd*) handle_cd "$cmd" ;;
        put*) handle_put $cmd ;;
        get*) handle_get $cmd ;;
        *) handle_command "$cmd" ;;
    esac
done
