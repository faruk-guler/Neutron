#!/bin/bash

# Color definitions
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly RED='\033[0;31m'
readonly NC='\033[0m'

# Constants
readonly HISTORY_FILE="$HOME/.neutron_history"
readonly SSH_CONTROL_PATH="$HOME/.ssh/neutron-%r@%h:%p"
# Consistent SSH timeout for all connections for better reliability
readonly SSH_CONNECT_TIMEOUT_SECONDS=10 
# SSH master options - ControlMaster, ControlPath, ControlPersist
readonly SSH_MASTER_OPTIONS="-o ControlMaster=auto -o ControlPath=$SSH_CONTROL_PATH -o ControlPersist=60s"
# Maximum theoretical size for connection pool (currently not actively enforced, but defines intent)
readonly MAX_POOL_SIZE=10 

# Global arrays for resource tracking
declare -A temp_files_registry
declare -A connection_pool
declare -A current_dir
declare -A host_ports
declare -A host_names
declare -A outputs
declare -A jobs
connection_pool_size=0

# Resource management functions
cleanup_temp_file() {
    local temp_file="$1"
    [ -n "$temp_file" ] && [ -f "$temp_file" ] && rm -f "$temp_file" 2>/dev/null
    unset temp_files_registry["$temp_file"]
}

cleanup_all_temp_files() {
    for temp_file in "${!temp_files_registry[@]}"; do
        cleanup_temp_file "$temp_file"
    done
}

create_temp_file() {
    local temp_file
    temp_file=$(mktemp) || {
        echo -e "${RED}Error: Failed to create temporary file${NC}" >&2
        return 1
    }
    temp_files_registry["$temp_file"]=1
    echo "$temp_file"
}

# Banner
print_banner() {
    echo -e "${CYAN}###########################################################${NC}" >&2
    echo -e "${GREEN}# Neutron v10 - Resource Management Fixed ${NC}" >&2
    echo -e "# Lightweight and Powerful automation tool for Linux/Unix" >&2
    echo -e "# Page: www.farukguler.com github.com/faruk-guler" >&2
    echo -e "# Author: faruk-guler" >&2
    echo >&2
    echo -e "${YELLOW}Neutron Usage:${NC}" >&2
    echo -e "${GREEN}cd <directory>${NC}            : Change directory on all remote hosts" >&2
    echo -e "${GREEN}put <local_path> [path]${NC} : Upload file/directory to all remote hosts (parallel)" >&2
    echo -e "${GREEN}get <remote_path> [dir]${NC} : Download file/directory from all remote hosts (parallel)" >&2
    echo -e "${GREEN}<any_shell_cmd>${NC}           : Run shell command on all remote hosts" >&2
    echo -e "${RED}exit${NC}                      : Exit Neutron" >&2
    echo -e "${CYAN}###########################################################${NC}" >&2
}

# Initialize history file
touch "$HISTORY_FILE"

# Readline settings
setup_readline() {
    if [[ $- == *i* ]]; then
        bind '"\e[A": history-search-backward'
        bind '"\e[B": history-search-forward'
        bind 'set show-all-if-ambiguous on'
        bind 'set completion-ignore-case on'
        bind 'TAB: menu-complete'
    fi
}

# Load configuration
load_config() {
    source config.ntr || { echo -e "${RED}Error: config.ntr not found! Please create it and enter your SSH credentials.${NC}" >&2; exit 1; }
    source sources.ntr || { echo -e "${RED}Error: sources.ntr not found! Please create it and enter your server list.${NC}" >&2; exit 1; }

    [ -z "${HOSTS+x}" ] && { echo -e "${RED}Error: HOSTS not defined in sources.ntr${NC}" >&2; exit 1; }
    [ -z "${USER+x}" ] && { echo -e "${RED}Error: USER not defined in config.ntr${NC}" >&2; exit 1; }
}

# Validate private key
validate_private_key() {
    local key_file="$1"

    [ -z "$key_file" ] && { echo -e "${RED}Error: PRIVATE_KEY_FILE not specified in config.ntr${NC}" >&2; return 1; }
    [ ! -f "$key_file" ] && { echo -e "${RED}Error: Private key file '$key_file' does not exist${NC}" >&2; return 1; }
    [ ! -r "$key_file" ] && { echo -e "${RED}Error: Private key file '$key_file' is not readable${NC}" >&2; return 1; }

    local perms=$(stat -c "%a" "$key_file" 2>/dev/null)
    [[ "$perms" != "600" && "$perms" != "400" ]] && echo -e "${YELLOW}Warning: Private key file permissions should be 600 or 400 (current: $perms)${NC}" >&2

    ssh-keygen -l -f "$key_file" >/dev/null 2>&1 || { echo -e "${RED}Error: Invalid private key format in '$key_file'${NC}" >&2; return 1; }
    return 0
}

# SSH connection management
setup_ssh_multiplexing() {
    local host_or_ip="$1"
    local port="$2"

    mkdir -p "$HOME/.ssh" 2>/dev/null

    if ! ssh -O check -o ControlPath="$SSH_CONTROL_PATH" "$USER@$host_or_ip" >/dev/null 2>&1; then
        ssh $SSH_MASTER_OPTIONS \
            -o ConnectTimeout="$SSH_CONNECT_TIMEOUT_SECONDS" \
            -o StrictHostKeyChecking=no \
            -p "$port" \
            -i "$PRIVATE_KEY_FILE" \
            -N -f \
            "$USER@$host_or_ip" >/dev/null 2>&1 && \
            echo -e "${GREEN}SSH multiplexing established for $host_or_ip${NC}" >&2 || \
            echo -e "${YELLOW}Warning: Could not establish SSH multiplexing for $host_or_ip${NC}" >&2
    fi
}

# Command builders
build_ssh_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"

    # Use the consistent SSH_CONNECT_TIMEOUT_SECONDS
    echo "$SSH_MASTER_OPTIONS $options -o ConnectTimeout=$SSH_CONNECT_TIMEOUT_SECONDS -o StrictHostKeyChecking=no -p $port -i $PRIVATE_KEY_FILE $USER@$host_or_ip"
}

build_scp_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"

    # Use the consistent SSH_CONNECT_TIMEOUT_SECONDS for SCP as well
    echo "$SSH_MASTER_OPTIONS $options -o ConnectTimeout=$SSH_CONNECT_TIMEOUT_SECONDS -P $port -o StrictHostKeyChecking=no -i $PRIVATE_KEY_FILE"
}

# Connection pool management
init_connection_pool() {
    echo -e "${BLUE}Initializing SSH connection pool...${NC}" >&2

    for host_port_entry in "${HOSTS[@]}"; do
        IFS=: read host_or_ip port <<< "$host_port_entry"
        setup_ssh_multiplexing "$host_or_ip" "$port"
        connection_pool["$host_or_ip"]="active"
        ((connection_pool_size++))
    done

    echo -e "${GREEN}Connection pool initialized with $connection_pool_size hosts${NC}" >&2
}

cleanup_ssh_connections() {
    echo -e "${BLUE}Cleaning up SSH connections...${NC}" >&2

    for host_or_ip in "${!connection_pool[@]}"; do
        ssh -O exit -o ControlPath="$SSH_CONTROL_PATH" "$USER@$host_or_ip" >/dev/null 2>&1
    done

    rm -f "$HOME/.ssh/neutron-"* 2>/dev/null
    echo -e "${GREEN}SSH connections cleaned up${NC}" >&2
}

# Command handlers
handle_cd() {
    # Extract directory, allowing for spaces if quoted
    local -a tokens
    IFS=' ' read -ra tokens <<< "$1"
    local dir="${tokens[@]:1}" # Get all tokens after "cd"

    if [ -z "$dir" ]; then
        echo -e "${YELLOW}Usage: cd <directory>${NC}" >&2
        return 1
    fi

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" ""))

        # Check directory existence and change
        if ssh "${ssh_cmd_arr[@]}" "test -d \"$dir\""; then
            if ssh "${ssh_cmd_arr[@]}" "cd \"$dir\""; then
                current_dir["$host_or_ip"]="$dir"
            else
                echo -e "${RED}Error: Could not change directory to '$dir' on ${host_names[$host_or_ip]}. Permissions issue?${NC}" >&2
            fi
        else
            echo -e "${YELLOW}Warning: Directory '$dir' does not exist on ${host_names[$host_or_ip]}.${NC}" >&2
        fi
    done
}

handle_put() {
    # Use IFS to parse local_path and remote_path robustly, considering quotes
    local -a tokens
    # Remove "put " prefix and read into array
    IFS=' ' read -ra tokens <<< "${1#put }"

    local local_path="${tokens[0]}"
    local remote_path="${tokens[1]:-/tmp}" # Default to /tmp if not specified

    if [ -z "$local_path" ]; then
        echo -e "${YELLOW}Usage: put <local_path> [remote_path]${NC}" >&2
        return 1
    fi

    if [ ! -e "$local_path" ]; then
        echo -e "${RED}Error: Local path '$local_path' does not exist.${NC}" >&2
        return 1
    fi

    # Clear jobs array before starting
    unset jobs
    declare -A jobs

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        echo -e "${GREEN}Uploading '$local_path' to ${host_names[$host_or_ip]}:${remote_path}${NC}" >&2

        local scp_cmd_arr=($(build_scp_cmd "$host_or_ip" "$port" ""))

        if [ -d "$local_path" ]; then
            scp "${scp_cmd_arr[@]}" -r "$local_path" "$USER@$host_or_ip:\"$remote_path\"" &
        else
            scp "${scp_cmd_arr[@]}" "$local_path" "$USER@$host_or_ip:\"$remote_path\"" &
        fi
        jobs["$host_or_ip"]="$!"
    done

    # Wait for all jobs and check results
    local upload_success=true
    for host_or_ip in "${!jobs[@]}"; do
        if wait "${jobs[$host_or_ip]}"; then
            echo -e "${GREEN}Successfully uploaded '$local_path' to ${host_names[$host_or_ip]}${NC}" >&2
        else
            echo -e "${RED}Failed to upload '$local_path' to ${host_names[$host_or_ip]}${NC}" >&2
            upload_success=false
        fi
    done

    # Clear jobs array after completion
    unset jobs
    declare -A jobs

    return $([[ "$upload_success" == true ]] && echo 0 || echo 1)
}

handle_get() {
    # Use IFS to parse remote_path and local_dir robustly, considering quotes
    local -a tokens
    # Remove "get " prefix and read into array
    IFS=' ' read -ra tokens <<< "${1#get }"

    local remote_path="${tokens[0]}"
    local local_dir="${tokens[1]:-./downloads}" # Default to ./downloads if not specified

    if [ -z "$remote_path" ]; then
        echo -e "${YELLOW}Usage: get <remote_path> [local_directory]${NC}" >&2
        return 1
    fi

    if ! mkdir -p "$local_dir" 2>/dev/null; then
        echo -e "${RED}Error: Cannot create or access directory '$local_dir'${NC}" >&2
        return 1
    fi

    # Clear jobs array before starting
    unset jobs
    declare -A jobs

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        echo -e "${GREEN}Downloading '$remote_path' from ${host_names[$host_or_ip]} to '$local_dir/'${NC}" >&2

        local scp_cmd_arr=($(build_scp_cmd "$host_or_ip" "$port" ""))
        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" ""))

        local target_host_dir="$local_dir/${host_names[$host_or_ip]}"
        if ! mkdir -p "$target_host_dir" 2>/dev/null; then
            echo -e "${RED}Error: Cannot create directory '$target_host_dir' for ${host_names[$host_or_ip]}${NC}" >&2
            continue
        fi

        # Check if remote path is a directory (use -d for robust check)
        local is_dir=$(ssh "${ssh_cmd_arr[@]}" "[ -d \"$remote_path\" ] && echo 'yes' || echo 'no'" 2>/dev/null)

        if [ "$is_dir" = "yes" ]; then
            # If remote is a directory, download into the target_host_dir
            scp "${scp_cmd_arr[@]}" -r "$USER@$host_or_ip:\"$remote_path\"" "$target_host_dir" &
        else
            # If remote is a file, download it directly to target_host_dir
            # Make sure the target file name is the same as the remote basename
            local target_file="$target_host_dir/$(basename "$remote_path")"
            scp "${scp_cmd_arr[@]}" "$USER@$host_or_ip:\"$remote_path\"" "$target_file" &
        fi
        jobs["$host_or_ip"]="$!"
    done

    # Wait for all jobs and check results
    local download_success=true
    for host_or_ip in "${!jobs[@]}"; do
        if wait "${jobs[$host_or_ip]}"; then
            echo -e "${GREEN}Successfully downloaded '$remote_path' from ${host_names[$host_or_ip]}${NC}" >&2
        else
            echo -e "${RED}Failed to download '$remote_path' from ${host_names[$host_or_ip]}${NC}" >&2
            download_success=false
        fi
    done

    # Clear jobs array after completion
    unset jobs
    declare -A jobs

    return $([[ "$download_success" == true ]] && echo 0 || echo 1)
}

handle_command() {
    local cmd="$1"
    local first_output_block=true
    local -a temp_files_created

    # Clear jobs and outputs arrays before starting
    unset jobs outputs
    declare -A jobs outputs

    # Create temp files and track them
    for host_or_ip in "${!current_dir[@]}"; do
        local temp_file
        temp_file=$(create_temp_file) || {
            echo -e "${RED}Error: Failed to create temporary file for ${host_names[$host_or_ip]}${NC}" >&2
            # Cleanup any temp files created so far
            for tf in "${temp_files_created[@]}"; do
                cleanup_temp_file "$tf"
            done
            return 1
        }
        temp_files_created+=("$temp_file")
        outputs["$host_or_ip"]="$temp_file"
    done

    # Execute commands on all hosts
    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" "-n"))
        local remote_cmd="cd \"${current_dir[$host_or_ip]}\" && $cmd"

        ssh "${ssh_cmd_arr[@]}" "$remote_cmd" > "${outputs[$host_or_ip]}" 2>&1 &
        jobs["$host_or_ip"]="$!"
    done

    # Wait for all jobs and process results
    for host_or_ip in "${!jobs[@]}"; do
        local wait_status=0
        wait "${jobs[$host_or_ip]}" || wait_status=$?

        local remote_display_name="${host_names[$host_or_ip]}"
        local temp_file="${outputs[$host_or_ip]}"
        
        # Read output safely
        local -a lines
        if [ -f "$temp_file" ]; then
            mapfile -t lines < "$temp_file"
        fi

        # Print output if there's any or if command failed
        if [ ${#lines[@]} -gt 0 ] || [ $wait_status -ne 0 ]; then
            ! $first_output_block && echo "" >&2 # Add a newline between blocks
            echo -e "${BLUE}host: ${remote_display_name}${NC}" >&2
            echo -e "${BLUE}--------------------------------------------${NC}" >&2

            if [ ${#lines[@]} -gt 0 ]; then
                printf "%s\n" "${lines[@]}" >&2
            fi

            if [ $wait_status -ne 0 ]; then
                echo -e "${RED}Command failed with exit status $wait_status on ${remote_display_name}${NC}" >&2
            fi
            echo -e "${RED}--------------------------------------------${NC}" >&2
        fi

        # Cleanup temp file immediately after use
        cleanup_temp_file "$temp_file"
        first_output_block=false
    done

    # Clear arrays after completion
    unset jobs outputs
    declare -A jobs outputs
}

# Initialize hostnames
init_hostnames() {
    for host_port_entry in "${HOSTS[@]}"; do
        IFS=: read host_or_ip port <<< "$host_port_entry"
        current_dir["$host_or_ip"]="/tmp"
        host_ports["$host_or_ip"]="$port"

        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" "-n"))
        local remote_hostname=$(ssh "${ssh_cmd_arr[@]}" "hostname" 2>/dev/null)

        host_names["$host_or_ip"]="${remote_hostname:-$host_or_ip}"
    done
}

# Comprehensive cleanup function
comprehensive_cleanup() {
    echo -e "${BLUE}Performing comprehensive cleanup...${NC}" >&2
    
    # Cleanup temp files
    cleanup_all_temp_files
    
    # Cleanup SSH connections
    cleanup_ssh_connections
    
    echo -e "${GREEN}Cleanup completed${NC}" >&2
}

# Main initialization
setup_readline
load_config
validate_private_key "$PRIVATE_KEY_FILE" || exit 1

# Initialize session data
init_connection_pool
init_hostnames

# Enhanced cleanup on exit - handles all resources
trap 'comprehensive_cleanup' EXIT INT TERM

# Load command history
history -r "$HISTORY_FILE"

# Main loop
print_banner
while read -e -p "$(echo -e "${GREEN}shell # ${NC}")" -r cmd; do
    history -s "$cmd"
    history -w "$HISTORY_FILE"

    [ -z "$cmd" ] && continue
    [ "$cmd" = "exit" ] && break

    # Clear jobs array for each new command cycle
    unset jobs
    declare -A jobs 

    case "$cmd" in
        cd\ *) handle_cd "$cmd" ;; # More specific pattern matching
        put\ *) handle_put "$cmd" ;;
        get\ *) handle_get "$cmd" ;;
        *) handle_command "$cmd" ;;
    esac
done
