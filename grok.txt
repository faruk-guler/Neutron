#!/usr/bin/env python3
import yaml
import paramiko
import sys
import threading
import time
import os
from queue import Queue

class SSHSession:
    def __init__(self, host, port, config):
        self.host = host
        self.port = port
        self.config = config
        self.client = paramiko.SSHClient()
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.shell = None
        self.output_queue = Queue()
        self.connected = False

    def connect(self):
        params = {
            'hostname': self.host,
            'port': self.port,
            'username': self.config['user'],
            'timeout': self.config.get('timeout', 30)
        }
        if self.config.get('key_path'):
            params['key_filename'] = self.config['key_path']
        else:
            params['password'] = os.getenv('SSH_PASSWORD', self.config.get('password'))

        try:
            self.client.connect(**params)
            self.shell = self.client.invoke_shell()
            self.connected = True
            threading.Thread(target=self._read_output, daemon=True).start()
        except Exception as e:
            print(f"{self.host}:{self.port} bağlantı hatası: {e}")

    def _read_output(self):
        while self.connected and self.shell and not self.shell.closed:
            if self.shell.recv_ready():
                data = self.shell.recv(4096).decode(errors='ignore')
                self.output_queue.put(data)
            time.sleep(0.1)

    def send_command(self, cmd):
        if self.connected and self.shell and not self.shell.closed:
            self.shell.send(cmd + '\n')
            return True
        return False

    def get_output(self, timeout=5):
        output = ""
        start_time = time.time()
        while time.time() - start_time < timeout and not self.output_queue.empty():
            output += self.output_queue.get()
        return output.strip()

    def close(self):
        self.connected = False
        if self.client:
            self.client.close()

class SSHTool:
    def __init__(self):
        self.config = self.load_yaml('config.yaml').get('ssh', {})
        self.sources = self.load_yaml('sources.yaml').get('sources', [])
        self.sessions = []
        self.validate_config()

    def load_yaml(self, path):
        try:
            with open(path) as f:
                data = yaml.safe_load(f) or {}
                if not data:
                    sys.exit(f"Hata: {path} boş veya geçersiz.")
                return data
        except Exception as e:
            sys.exit(f"Hata: {path} okunamadı: {e}")

    def validate_config(self):
        if 'user' not in self.config:
            sys.exit("Hata: config.yaml'da 'user' eksik.")
        if not self.config.get('key_path') and not os.getenv('SSH_PASSWORD') and not self.config.get('password'):
            sys.exit("Hata: Şifre veya anahtar dosyası belirtilmeli.")
        if not self.sources:
            sys.exit("Hata: sources.yaml'da sunucu listesi boş.")
        for s in self.sources:
            if isinstance(s, dict) and 'host' not in s:
                sys.exit(f"Hata: sources.yaml'da host eksik: {s}")

    def setup_sessions(self):
        for s in self.sources:
            host = s if isinstance(s, str) else s['host']
            port = self.config.get('port', 22) if isinstance(s, str) else s.get('port', self.config.get('port', 22))
            session = SSHSession(host, port, self.config)
            session.connect()
            if session.connected:
                self.sessions.append(session)

    def interactive_mode(self):
        print("SSH Aracı: Komut girin, 'exit' ile çıkın.")
        while True:
            try:
                cmd = input("ssh> ").strip()
                if cmd.lower() == 'exit':
                    break
                if not cmd:
                    continue

                for session in self.sessions:
                    if session.send_command(cmd):
                        time.sleep(0.5)
                        output = session.get_output()
                        print(f"\n{session.host}:{session.port} > {cmd}\n{output or '(çıktı yok)'}")
            except KeyboardInterrupt:
                print("\nProgram sonlandırılıyor...")
                break
            except Exception as e:
                print(f"Hata oluştu: {e}")

    def close_all(self):
        for s in self.sessions:
            s.close()

if __name__ == "__main__":
    tool = SSHTool()
    tool.setup_sessions()
    try:
        tool.interactive_mode()
    finally:
        tool.close_all()
        print("Tüm oturumlar kapatıldı.")
