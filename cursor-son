#!/bin/bash

# Color definitions
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly RED='\033[0;31m'
readonly NC='\033[0m'

# Constants
readonly HISTORY_FILE="$HOME/.neutron_history"
readonly SSH_CONTROL_PATH="$HOME/.ssh/neutron-%r@%h:%p"
# Consistent SSH timeout for all connections for better reliability
readonly SSH_CONNECT_TIMEOUT_SECONDS=10
# SSH master options - ControlMaster, ControlPath, ControlPersist
readonly SSH_MASTER_OPTIONS="-o ControlMaster=auto -o ControlPath=$SSH_CONTROL_PATH -o ControlPersist=60s"
# Maximum theoretical size for connection pool (currently not actively enforced, but defines intent)
readonly MAX_POOL_SIZE=10

# Banner
print_banner() {
    echo -e "${CYAN}###########################################################${NC}" >&2
    echo -e "${GREEN}# Neutron v10 ${NC}" >&2
    echo -e "# Lightweight and Powerful automation tool for Linux/Unix" >&2
    echo -e "# Page: www.farukguler.com github.com/faruk-guler" >&2
    echo -e "# Author: faruk-guler" >&2
    echo >&2
    echo -e "${YELLOW}Neutron Usage:${NC}" >&2
    echo -e "${GREEN}cd <directory>${NC}            : Change directory on all remote hosts" >&2
    echo -e "${GREEN}put <local_path> [path]${NC} : Upload file/directory to all remote hosts (parallel)" >&2
    echo -e "${GREEN}get <remote_path> [dir]${NC} : Download file/directory from all remote hosts (parallel)" >&2
    echo -e "${GREEN}<any_shell_cmd>${NC}           : Run shell command on all remote hosts" >&2
    echo -e "${RED}exit${NC}                      : Exit Neutron" >&2
    echo -e "${CYAN}###########################################################${NC}" >&2
}

# Initialize history file
touch "$HISTORY_FILE"

# Readline settings
setup_readline() {
    if [[ $- == *i* ]]; then
        bind '"\e[A": history-search-backward'
        bind '"\e[B": history-search-forward'
        bind 'set show-all-if-ambiguous on'
        bind 'set completion-ignore-case on'
        bind 'TAB: menu-complete'
    fi
}

# Load configuration
load_config() {
    source config.ntr || { echo -e "${RED}Error: config.ntr not found! Please create it and enter your SSH credentials.${NC}" >&2; exit 1; }
    source sources.ntr || { echo -e "${RED}Error: sources.ntr not found! Please create it and enter your server list.${NC}" >&2; exit 1; }

    [ -z "${HOSTS+x}" ] && { echo -e "${RED}Error: HOSTS not defined in sources.ntr${NC}" >&2; exit 1; }
    [ -z "${USER+x}" ] && { echo -e "${RED}Error: USER not defined in config.ntr${NC}" >&2; exit 1; }
}

# Validate private key
validate_private_key() {
    local key_file="$1"

    [ -z "$key_file" ] && { echo -e "${RED}Error: PRIVATE_KEY_FILE not specified in config.ntr${NC}" >&2; return 1; }
    [ ! -f "$key_file" ] && { echo -e "${RED}Error: Private key file '$key_file' does not exist${NC}" >&2; return 1; }
    [ ! -r "$key_file" ] && { echo -e "${RED}Error: Private key file '$key_file' is not readable${NC}" >&2; return 1; }

    local perms=$(stat -c "%a" "$key_file" 2>/dev/null)
    [[ "$perms" != "600" && "$perms" != "400" ]] && echo -e "${YELLOW}Warning: Private key file permissions should be 600 or 400 (current: $perms)${NC}" >&2

    ssh-keygen -l -f "$key_file" >/dev/null 2>&1 || { echo -e "${RED}Error: Invalid private key format in '$key_file'${NC}" >&2; return 1; }
    return 0
}

# SSH connection management
setup_ssh_multiplexing() {
    local host_or_ip="$1"
    local port="$2"

    mkdir -p "$HOME/.ssh" 2>/dev/null

    if ! ssh -O check -o ControlPath="$SSH_CONTROL_PATH" "$USER@$host_or_ip" >/dev/null 2>&1; then
        ssh $SSH_MASTER_OPTIONS \
            -o ConnectTimeout="$SSH_CONNECT_TIMEOUT_SECONDS" \
            -o StrictHostKeyChecking=no \
            -p "$port" \
            -i "$PRIVATE_KEY_FILE" \
            -N -f \
            "$USER@$host_or_ip" >/dev/null 2>&1 && \
            echo -e "${GREEN}SSH multiplexing established for $host_or_ip${NC}" >&2 || \
            echo -e "${YELLOW}Warning: Could not establish SSH multiplexing for $host_or_ip${NC}" >&2
    fi
}

# Command builders
build_ssh_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"

    # Use the consistent SSH_CONNECT_TIMEOUT_SECONDS
    echo "$SSH_MASTER_OPTIONS $options -o ConnectTimeout=$SSH_CONNECT_TIMEOUT_SECONDS -o StrictHostKeyChecking=no -p $port -i $PRIVATE_KEY_FILE $USER@$host_or_ip"
}

build_scp_cmd() {
    local host_or_ip="$1"
    local port="$2"
    local options="$3"

    # Use the consistent SSH_CONNECT_TIMEOUT_SECONDS for SCP as well
    echo "$SSH_MASTER_OPTIONS $options -o ConnectTimeout=$SSH_CONNECT_TIMEOUT_SECONDS -P $port -o StrictHostKeyChecking=no -i $PRIVATE_KEY_FILE"
}

# Connection pool management
declare -A connection_pool
connection_pool_size=0

init_connection_pool() {
    echo -e "${BLUE}Initializing SSH connection pool...${NC}" >&2

    for host_port_entry in "${HOSTS[@]}"; do
        IFS=: read host_or_ip port <<< "$host_port_entry"
        setup_ssh_multiplexing "$host_or_ip" "$port"
        connection_pool["$host_or_ip"]="active"
        ((connection_pool_size++))
    done

    echo -e "${GREEN}Connection pool initialized with $connection_pool_size hosts${NC}" >&2
}

cleanup_ssh_connections() {
    echo -e "${BLUE}Cleaning up SSH connections...${NC}" >&2

    for host_or_ip in "${!connection_pool[@]}"; do
        ssh -O exit -o ControlPath="$SSH_CONTROL_PATH" "$USER@$host_or_ip" >/dev/null 2>&1
    done

    rm -f "$HOME/.ssh/neutron-"* 2>/dev/null
    echo -e "${GREEN}SSH connections cleaned up${NC}" >&2
}

# Command handlers
handle_cd() {
    # Extract directory, allowing for spaces if quoted
    local -a tokens
    IFS=' ' read -ra tokens <<< "$1"
    local dir="${tokens[@]:1}" # Get all tokens after "cd"

    if [ -z "$dir" ]; then
        echo -e "${YELLOW}Usage: cd <directory>${NC}" >&2
        return 1
    fi

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" ""))

        # Check directory existence and change
        if ssh "${ssh_cmd_arr[@]}" "test -d \"$dir\""; then
            if ssh "${ssh_cmd_arr[@]}" "cd \"$dir\""; then
                current_dir["$host_or_ip"]="$dir"
            else
                echo -e "${RED}Error: Could not change directory to '$dir' on ${host_names[$host_or_ip]}. Permissions issue?${NC}" >&2
            fi
        else
            echo -e "${YELLOW}Warning: Directory '$dir' does not exist on ${host_names[$host_or_ip]}.${NC}" >&2
        fi
    done
}

handle_put() {
    # Use IFS to parse local_path and remote_path robustly, considering quotes
    local -a tokens
    # Remove "put " prefix and read into array
    IFS=' ' read -ra tokens <<< "${1#put }"

    local local_path="${tokens[0]}"
    local remote_path="${tokens[1]:-/tmp}" # Default to /tmp if not specified

    if [ -z "$local_path" ]; then
        echo -e "${YELLOW}Usage: put <local_path> [remote_path]${NC}" >&2
        return 1
    fi

    if [ ! -e "$local_path" ]; then
        echo -e "${RED}Error: Local path '$local_path' does not exist.${NC}" >&2
        return 1
    fi

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        echo -e "${GREEN}Uploading '$local_path' to ${host_names[$host_or_ip]}:${remote_path}${NC}" >&2

        local scp_cmd_arr=($(build_scp_cmd "$host_or_ip" "$port" ""))

        if [ -d "$local_path" ]; then
            scp "${scp_cmd_arr[@]}" -r "$local_path" "$USER@$host_or_ip:\"$remote_path\"" &
        else
            scp "${scp_cmd_arr[@]}" "$local_path" "$USER@$host_or_ip:\"$remote_path\"" &
        fi
        jobs["$host_or_ip"]="$!"
    done

    for host_or_ip in "${!jobs[@]}"; do
        wait "${jobs[$host_or_ip]}"
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Successfully uploaded '$local_path' to ${host_names[$host_or_ip]}${NC}" >&2
        else
            echo -e "${RED}Failed to upload '$local_path' to ${host_names[$host_or_ip]}${NC}" >&2
        fi
    done
}

handle_get() {
    # Use IFS to parse remote_path and local_dir robustly, considering quotes
    local -a tokens
    # Remove "get " prefix and read into array
    IFS=' ' read -ra tokens <<< "${1#get }"

    local remote_path="${tokens[0]}"
    local local_dir="${tokens[1]:-./downloads}" # Default to ./downloads if not specified

    if [ -z "$remote_path" ]; then
        echo -e "${YELLOW}Usage: get <remote_path> [local_directory]${NC}" >&2
        return 1
    fi

    mkdir -p "$local_dir" 2>/dev/null || { echo -e "${RED}Error: Cannot create or access directory '$local_dir'${NC}" >&2; return 1; }

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        echo -e "${GREEN}Downloading '$remote_path' from ${host_names[$host_or_ip]} to '$local_dir/'${NC}" >&2

        local scp_cmd_arr=($(build_scp_cmd "$host_or_ip" "$port" ""))
        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" ""))

        local target_host_dir="$local_dir/${host_names[$host_or_ip]}"
        mkdir -p "$target_host_dir" 2>/dev/null || { echo -e "${RED}Error: Cannot create directory '$target_host_dir' for ${host_names[$host_or_ip]}${NC}" >&2; continue; }

        # Check if remote path is a directory (use -d for robust check)
        local is_dir=$(ssh "${ssh_cmd_arr[@]}" "[ -d \"$remote_path\" ] && echo 'yes' || echo 'no'" 2>/dev/null)

        if [ "$is_dir" = "yes" ]; then
            # If remote is a directory, download into the target_host_dir
            scp "${scp_cmd_arr[@]}" -r "$USER@$host_or_ip:\"$remote_path\"" "$target_host_dir" &
        else
            # If remote is a file, download it directly to target_host_dir
            # Make sure the target file name is the same as the remote basename
            local target_file="$target_host_dir/$(basename "$remote_path")"
            scp "${scp_cmd_arr[@]}" "$USER@$host_or_ip:\"$remote_path\"" "$target_file" &
        fi
        jobs["$host_or_ip"]="$!"
    done

    for host_or_ip in "${!jobs[@]}"; do
        wait "${jobs[$host_or_ip]}"
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}Successfully downloaded '$remote_path' from ${host_names[$host_or_ip]}${NC}" >&2
        else
            echo -e "${RED}Failed to download '$remote_path' from ${host_names[$host_or_ip]}${NC}" >&2
        fi
    done
}

handle_command() {
    local cmd="$1"
    local first_output_block=true

    for host_or_ip in "${!current_dir[@]}"; do
        local port="${host_ports[$host_or_ip]}"
        local temp_file=$(mktemp)
        outputs["$host_or_ip"]="$temp_file"

        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" "-n"))
        local remote_cmd="cd \"${current_dir[$host_or_ip]}\" && $cmd"

        ssh "${ssh_cmd_arr[@]}" "$remote_cmd" > "$temp_file" 2>&1 &
        jobs["$host_or_ip"]="$!"
    done

    for host_or_ip in "${!jobs[@]}"; do
        wait_status=0
        wait "${jobs[$host_or_ip]}" || wait_status=$?

        local remote_display_name="${host_names[$host_or_ip]}"
        mapfile -t lines < "${outputs[$host_or_ip]}"

        # Print output if there's any or if command failed
        if [ ${#lines[@]} -gt 0 ] || [ $wait_status -ne 0 ]; then
            ! $first_output_block && echo "" >&2 # Add a newline between blocks, direct to stderr
            echo -e "${BLUE}host: ${remote_display_name}${NC}" >&2
            echo -e "${BLUE}--------------------------------------------${NC}" >&2

            if [ ${#lines[@]} -gt 0 ]; then
                printf "%s\n" "${lines[@]}" >&2 # Output actual command results to stderr as well
            fi

            if [ $wait_status -ne 0 ]; then
                echo -e "${RED}Command failed with exit status $wait_status on ${remote_display_name}${NC}" >&2
            fi
            echo -e "${RED}--------------------------------------------${NC}" >&2
        fi
        rm "${outputs[$host_or_ip]}"
        first_output_block=false
    done
}

# Initialize hostnames
init_hostnames() {
    for host_port_entry in "${HOSTS[@]}"; do
        IFS=: read host_or_ip port <<< "$host_port_entry"
        current_dir["$host_or_ip"]="/tmp"
        host_ports["$host_or_ip"]="$port"

        local ssh_cmd_arr=($(build_ssh_cmd "$host_or_ip" "$port" "-n"))
        local remote_hostname=$(ssh "${ssh_cmd_arr[@]}" "hostname" 2>/dev/null)

        host_names["$host_or_ip"]="${remote_hostname:-$host_or_ip}"
    done
}

# Main initialization
setup_readline
load_config
validate_private_key "$PRIVATE_KEY_FILE" || exit 1

# Initialize session data
declare -A current_dir host_ports host_names outputs jobs # 'jobs' declared globally for main loop
init_connection_pool
init_hostnames

# Cleanup on exit
trap 'rm -f "${outputs[@]}"; cleanup_ssh_connections' EXIT

# Load command history
history -r "$HISTORY_FILE"

# Main loop
print_banner
while read -e -p "$(echo -e "${GREEN}shell # ${NC}")" -r cmd; do
    history -s "$cmd"
    history -w "$HISTORY_FILE"

    [ -z "$cmd" ] && continue
    [ "$cmd" = "exit" ] && break

    # Clear jobs array for each new command cycle
    # 'jobs' array is now global and reused, so explicitly clear it
    unset jobs
    declare -A jobs

    case "$cmd" in
        cd\ *) handle_cd "$cmd" ;; # More specific pattern matching
        put\ *) handle_put "$cmd" ;;
        get\ *) handle_get "$cmd" ;;
        *) handle_command "$cmd" ;;
    esac
done
