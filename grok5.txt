#!/usr/bin/env python3
import yaml
import paramiko
import colorama
import os
import sys
import threading
import logging
from typing import List, Dict
from concurrent.futures import ThreadPoolExecutor, as_completed

# Initialize colorama for cross-platform terminal colors
colorama.init(autoreset=True)

# Configure logging to neutron.log
logging.basicConfig(
    filename='neutron.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)


class LinuxSSHTool:
    """
    Klasik bir SSH aracı: Birden fazla Linux sunucusuna komut gönderir ve çıktıları toplar.
    Paralel/sıralı çalıştırma, interaktif mod ve görev dosyalarını destekler.
    A classic SSH tool: Executes commands on multiple Linux servers and collects outputs.
    Supports parallel/serial execution, interactive mode, and task files.
    """
    def __init__(self):
        """
        Aracı başlatır, yapılandırma ve sunucu listesini yükler.
        SSH oturum önbelleği ve çıktı senkronizasyonu için kilit ayarlar.
        Initializes the tool, loads configuration and server list.
        Sets up SSH session cache and output synchronization lock.
        """
        self.config = self.load_config()
        self.servers = self.load_servers()
        self.ssh_sessions = {}  # host:port -> SSHClient
        self.print_lock = threading.Lock()

    def load_config(self) -> Dict:
        """
        config.cfg dosyasından SSH yapılandırmasını yükler.
        Gereksinimler:
            - config.cfg boş veya geçersiz olmamalı.
            - SSH kullanıcısı tanımlı olmalı.
            - key_path veya password sağlanmalı (ikisi birden değil).
            - max_workers (varsayılan: 10), timeout (varsayılan: 30) ayarlanıyor.
        Loads SSH configuration from config.cfg.
        Requirements:
            - config.cfg must not be empty or invalid.
            - SSH user must be defined.
            - Either key_path or password must be provided (not both).
            - max_workers (default: 10) and timeout (default: 30) are set.
        """
        try:
            with open('config.cfg') as f:
                config = yaml.safe_load(f)
                if not config:
                    raise ValueError("config.cfg is empty or invalid.")

            ssh_config = config.get('ssh')
            if not ssh_config or not ssh_config.get('user'):
                raise ValueError("Invalid config.cfg: SSH user is not defined.")

            if ssh_config.get('key_path') and ssh_config.get('password'):
                raise ValueError("Please provide either a key_path or password, not both.")

            if not ssh_config.get('key_path') and not ssh_config.get('password'):
                raise ValueError("No authentication method provided: Define either key_path or password.")

            ssh_config['max_workers'] = ssh_config.get('max_workers', 10)
            ssh_config['timeout'] = ssh_config.get('timeout', 30)
            ssh_config['port'] = ssh_config.get('port', 22)
            return ssh_config

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}[ERROR] Failed to load config: {e}")
                logging.error(f"Failed to load config: {e}")
            sys.exit(1)

    def load_servers(self) -> List[Dict]:
        """
        source.yaml dosyasından sunucu listesini yükler.
        - source.yaml geçerli ve boş olmamalı.
        - Her sunucunun geçerli bir host ve port değeri olmalı.
        Loads the list of servers from source.yaml.
        - source.yaml must be valid and non-empty.
        - Each server must have a valid host and port.
        """
        try:
            with open('source.yaml') as f:
                data = yaml.safe_load(f)
                if not data:
                    raise ValueError("source.yaml is empty or invalid.")
                servers = data.get('servers', [])

            normalized = []
            for s in servers:
                if isinstance(s, str):
                    if not s.strip():
                        raise ValueError("Empty host provided in source.yaml")
                    normalized.append({'host': s.strip(), 'port': self.config.get('port', 22)})
                elif isinstance(s, dict):
                    host = s.get('host')
                    if not host or not host.strip():
                        raise ValueError("Invalid or empty host in source.yaml")
                    port = s.get('port', self.config.get('port', 22))
                    if not isinstance(port, int) or port <= 0 or port > 65535:
                        raise ValueError(f"Invalid port for host {host}: {port}")
                    normalized.append({'host': host.strip(), 'port': port})
                else:
                    raise ValueError("Server items must be either string or dict.")
            return normalized

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}[ERROR] Failed to load server list: {e}")
                logging.error(f"Failed to load server list: {e}")
            sys.exit(1)

    def get_ssh_session(self, host: str, port: int) -> paramiko.SSHClient:
        """
        Verilen host ve port için SSH oturumu alır veya oluşturur.
        Performansı artırmak için mevcut bağlantıları yeniden kullanır.
        Gets or creates an SSH session for the given host and port.
        Reuses existing connections to improve performance.
        """
        key = f"{host}:{port}"
        if key not in self.ssh_sessions:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            connect_params = {
                'hostname': host,
                'port': port,
                'username': self.config['user'],
            }
            if self.config.get('key_path'):
                connect_params['key_filename'] = os.path.expanduser(self.config['key_path'])
            elif self.config.get('password'):
                connect_params['password'] = self.config['password']
            ssh.connect(**connect_params)
            self.ssh_sessions[key] = ssh
        return self.ssh_sessions[key]

    def run_command(self, host: str, port: int, command: str):
        """
        Uzak sunucuda komut çalıştırır.
        - Tehlikeli komutları kontrol eder ve onay gerektirir.
        - get_pty=True ile terminal bağımlı komutlar (örn. clear) desteklenir.
        - TERM=xterm ayarlanarak TERM hataları önlenir.
        Runs a command on a remote host via SSH.
        - Checks for dangerous commands and requires confirmation.
        - Uses get_pty=True for terminal-dependent commands (e.g., clear).
        - Sets TERM=xterm to prevent TERM-related errors.
        """
        dangerous_commands = ['rm -rf /', 'reboot', 'shutdown']
        if any(dc in command.lower() for dc in dangerous_commands):
            with self.print_lock:
                print(f"{colorama.Fore.RED}   ⚠️ Dangerous command detected: {command}")
                if input("Continue? (y/n): ").lower() != 'y':
                    return

        try:
            with self.print_lock:
                print(f"\n{colorama.Fore.CYAN}🔹 Connecting to {host}:{port}")
                print(f"   {colorama.Fore.YELLOW}$ {command}")
                logging.info(f"Connecting to {host}:{port} to run: {command}")

            ssh = self.get_ssh_session(host, port)
            env_command = f"export TERM=xterm; {command}"
            stdin, stdout, stderr = ssh.exec_command(
                env_command,
                timeout=self.config['timeout'],
                get_pty=True
            )
            output = stdout.read().decode().strip()
            error = stderr.read().decode().strip()

            with self.print_lock:
                if output:
                    if len(output) > 1000:
                        print(f"{colorama.Fore.GREEN}   ✅ Output ({host}, truncated):\n{output[:1000]}...")
                        output_file = f"output_{host}_{port}.txt"
                        with open(output_file, 'w') as f:
                            f.write(output)
                        print(f"{colorama.Fore.YELLOW}   📝 Full output saved to {output_file}")
                        logging.info(f"Output from {host}:{port} saved to {output_file}")
                    else:
                        print(f"{colorama.Fore.GREEN}   ✅ Output ({host}):\n{output}")
                        logging.info(f"Output from {host}:{port}: {output}")
                if error:
                    print(f"{colorama.Fore.RED}   ❗ Error ({host}):\n{error}")
                    logging.error(f"Error from {host}:{port}: {error}")
                if not output and not error:
                    print(f"{colorama.Fore.YELLOW}   ⚠️ No output returned from {host}.")
                    logging.info(f"No output from {host}:{port}")

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}   ❌ Connection error on {host}: {str(e)}")
                logging.error(f"Connection error on {host}:{port}: {str(e)}")
            raise

    def execute_task(self, task_file: str):
        """
        YAML görev dosyasındaki komutları tüm sunucularda çalıştırır.
        'parallel' anahtarına bağlı olarak paralel veya sıralı çalıştırma destekler.
        Örnek görev dosyası:
            parallel: true
            commands:
              - "uptime"
              - "df -h"
        Executes commands from a YAML task file on all servers.
        Supports parallel or serial execution based on 'parallel' key.
        """
        try:
            with open(task_file) as f:
                task_data = yaml.safe_load(f)
                if not task_data:
                    raise ValueError("Task file is empty or invalid.")
                commands = task_data.get('commands', [])
                if not commands:
                    raise ValueError("No commands defined in the task file.")
                parallel = task_data.get('parallel', True)

            with self.print_lock:
                print(f"{colorama.Fore.BLUE}[INFO] Executing task file: {task_file}")
                print(f"{colorama.Fore.BLUE}[INFO] Parallel execution: {'Enabled' if parallel else 'Disabled'}")
                logging.info(f"Executing task file: {task_file}, Parallel: {parallel}")

            errors = []
            if parallel:
                max_workers = self.config.get('max_workers', 10)
                with ThreadPoolExecutor(max_workers=max_workers) as executor:
                    futures = [
                        executor.submit(self.run_command, server['host'], server['port'], cmd)
                        for server in self.servers
                        for cmd in commands
                    ]
                    for future in as_completed(futures):
                        try:
                            future.result()
                        except Exception as e:
                            errors.append(str(e))
            else:
                for server in self.servers:
                    for cmd in commands:
                        try:
                            self.run_command(server['host'], server['port'], cmd)
                        except Exception as e:
                            errors.append(str(e))

            if errors:
                with self.print_lock:
                    print(f"{colorama.Fore.RED}[SUMMARY] Errors occurred during execution:")
                    for error in errors:
                        print(f"{colorama.Fore.RED}  - {error}")
                    logging.error(f"Task execution errors: {errors}")

        except Exception as e:
            with self.print_lock:
                print(f"{colorama.Fore.RED}[ERROR] Task execution failed: {e}")
                logging.error(f"Task execution failed: {e}")

    def interactive_mode(self):
        """
        Interaktif mod: Kullanıcı terminalden komut girer, tüm sunucularda çalışır.
        'parallel:on/off' ile paralel/sıralı çalıştırma arasında geçiş yapabilir.
        Interactive mode: User inputs commands, executed on all servers.
        'parallel:on/off' switches between parallel/serial execution.
        """
        print(f"{colorama.Fore.MAGENTA}#######################################################################")
        print(f"{colorama.Fore.MAGENTA}###                            NEUTRON                              ###")
        print(f"{colorama.Fore.MAGENTA}### 🐧 Classic SSH tool for Linux (Type 'exit' to quit)            ###")
        print(f"{colorama.Fore.MAGENTA}###                     www.farukguler.com                         ###")
        print(f"{colorama.Fore.MAGENTA}#######################################################################")
        print(f"{colorama.Fore.BLUE}[INFO] Maximum parallel connections: {self.config.get('max_workers', 10)}")
        print(f"{colorama.Fore.BLUE}[INFO] Command timeout: {self.config.get('timeout', 30)} seconds")
        print(f"{colorama.Fore.BLUE}[INFO] Available commands:")
        print(f"{colorama.Fore.BLUE}       - Type a shell command to execute on all servers")
        print(f"{colorama.Fore.BLUE}       - Type 'parallel:on' to enable parallel execution")
        print(f"{colorama.Fore.BLUE}       - Type 'parallel:off' to disable parallel execution")
        print(f"{colorama.Fore.BLUE}       - Type 'exit' or 'quit' to exit")

        parallel_mode = False
        while True:
            try:
                cmd = input(f"{colorama.Fore.CYAN}\nssh{'(parallel)' if parallel_mode else ''}> ").strip()
                if cmd.lower() in ['exit', 'quit']:
                    break
                elif cmd.lower() == 'parallel:on':
                    parallel_mode = True
                    print(f"{colorama.Fore.GREEN}[INFO] Parallel execution enabled")
                    logging.info("Parallel execution enabled")
                    continue
                elif cmd.lower() == 'parallel:off':
                    parallel_mode = False
                    print(f"{colorama.Fore.GREEN}[INFO] Parallel execution disabled")
                    logging.info("Parallel execution disabled")
                    continue

                errors = []
                if parallel_mode:
                    max_workers = self.config.get('max_workers', 10)
                    with ThreadPoolExecutor(max_workers=max_workers) as executor:
                        futures = [
                            executor.submit(self.run_command, server['host'], server['port'], cmd)
                            for server in self.servers
                        ]
                        for future in as_completed(futures):
                            try:
                                future.result()
                            except Exception as e:
                                errors.append(str(e))
                else:
                    for server in self.servers:
                        try:
                            self.run_command(server['host'], server['port'], cmd)
                        except Exception as e:
                            errors.append(str(e))

                if errors:
                    with self.print_lock:
                        print(f"{colorama.Fore.RED}[SUMMARY] Errors occurred during execution:")
                        for error in errors:
                            print(f"{colorama.Fore.RED}  - {error}")
                        logging.error(f"Interactive mode errors: {errors}")

            except KeyboardInterrupt:
                print(f"{colorama.Fore.RED}\nExiting...")
                logging.info("Exiting interactive mode")
                break

    def __del__(self):
        """
        Nesne yok edildiğinde tüm SSH oturumlarını kapatır.
        Closes all SSH sessions when the object is destroyed.
        """
        for ssh in self.ssh_sessions.values():
            ssh.close()


if __name__ == "__main__":
    tool = LinuxSSHTool()
    if len(sys.argv) > 1:
        tool.execute_task(sys.argv[1])
    else:
        tool.interactive_mode()
